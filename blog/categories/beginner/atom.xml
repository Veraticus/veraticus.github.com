<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: beginner | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/beginner/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-08-13T14:47:06-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to Programming II]]></title>
    <link href="http://joshsymonds.com/blog/2012/08/05/introduction-to-programming-ii/"/>
    <updated>2012-08-05T17:48:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/08/05/introduction-to-programming-ii</id>
    <content type="html"><![CDATA[<p>It took me a long time to author this -- and to update this blog in general, in fact. RubyMotion has turned out to be fun and profitable, but also exhausting; I'm engaged in another RubyMotion project that has taken up most of the free time I used to dedicate to this blog.</p>

<p>Still, I committed to making an entire series, starting with <a href="http://joshsymonds.com/blog/2012/04/24/introduction-to-programming-i/">Introduction to Programming I</a>, and this is the next in that line. I hope someone finds it useful! I actually made edits to the last post to remove references to sandRBox -- I'm using <a href="http://repl.it">repl.it</a> now, since that runs on the individual's browser.</p>

<!-- more -->


<h2>Digging Deeper into Ruby</h2>

<p>In our last lesson, we used an online tool (<a href="http://repl.it">repl.it</a>) to understand the basics of the Ruby programming language. We learned some of the basic objects of Ruby -- integers, strings, and floats -- and we also learned what methods are and how they can be used to manipulate those objects. Today we'll start by learning about variables, a key concept in computer programming. Afterwards, we'll use variables to understand more about Ruby's basic objects, and then we'll discover how we can create and manipulate entirely new classes of objects.</p>

<h3>Variables</h3>

<p>A variable is a way of naming data. Why would you want to do this? In computer programs, you'll need to reference the same piece of data over and over again. Maybe you have a string that's particularly important to you; maybe you want to store the result of a calculation so you can refer to it later; or maybe you have an open file that you need to read data from. Variables let you accomplish these goals and more.</p>

<p>In Ruby, variable names are all lower-case, and they can't contain numbers or spaces. <code>variable</code>, <code>this_is_a_long_name</code>, and <code>specialsauce</code> are all valid variable names. In order to use a variable, you just assign it to any Ruby object with an equal sign, like this: <code>mary = 'little lamb'</code>. Now you can always refer to that same <code>'little lamb'</code> string by using the <code>mary</code> variable. If you type the variable name by itself into repl.it, you'll see its value: so when you type <code>mary</code>, you'll see <code>"little lamb"</code>.</p>

<p>Let's do a quick <strong>exercise</strong> to understand the power and importance of variables in Ruby.</p>

<ol>
<li><p>Try <code>mary = 'little lamb'</code>. Now, type <code>mary</code>. It has the value of <code>'little lamb'</code>. This is how you assign variables.</p></li>
<li><p>Let's put our variable to use! Try <code>mary + 'chop'</code>. <code>mary</code> is exactly equivalent to <code>'little lamb'</code>: essentially, <code>mary</code> is the name of that string, now, and every time you call it by its name you're actually using that string. So when you type <code>mary + 'chop'</code>, you're actually saying <code>'little lamb' + 'chop'</code>.</p></li>
<li><p>Try <code>mary</code> again. Note that even though we saw <code>'little lambchop</code>' previously, <code>mary</code>'s value hasn't changed. The only way to change the value of a variable is to assign it with an equals sign.</p></li>
<li><p>Try <code>mary = mary + 'chop'</code>. Now the variable <code>mary</code> is going to be <code>'little lambchop'</code>, because we assigned it again.</p></li>
<li><p>Try <code>dinner = mary</code>. The variable <code>dinner</code> now has the same value as the variable <code>mary</code>, which is to say, <code>'little lambchop'</code>.</p></li>
<li><p>Let's change what we're having for dinner. Try <code>dinner = 'big lambchop'</code>. We've changed the value of <code>dinner</code>: what do you think's happened to the value of <code>mary</code>?</p></li>
<li><p>Try <code>mary</code> to find out. Are you surprised that its value hasn't changed? Each variable gets its own copy of the object you assigned to it. Changing the value of one variable doesn't affect any other similarly-assigned variables. Even though <code>dinner</code> and <code>mary</code> looked like they had the same value, actually each of them had a copy of the same string.</p></li>
<li><p>Let's use some numbers with variables. Try <code>number = 3</code>. Then do some basic math. Try <code>number + number</code>, <code>number * number</code>, and <code>number / number</code>.</p></li>
<li><p>Finally, let's change our number. Try <code>number = number * 3</code>.</p></li>
</ol>


<p>Reassignment of an existing variable (as in <code>number = number * 3</code>) is an extremely common pattern in any programming language. It's so common, in fact, that Ruby provides some clever shorthand to make it even easier to do.</p>

<p>Let's explore variable reassignment in an <strong>exercise</strong>.</p>

<ol>
<li><p>Try <code>mary = 'little lamb'</code>. Now, try <code>mary += 'chop'</code>. This is exactly equivalent to <code>mary = mary + 'chop'</code>.</p></li>
<li><p>Try <code>number = 3</code>. Now, try <code>number *= 4</code>. This is exactly equivalent to <code>number = number * 4</code>.</p></li>
</ol>


<p>There are shortcuts for division (<code>/=</code>) and subtraction (<code>-=</code>) reassignment as well, if you ever need those.</p>

<p>Now that we understand variables, the rest of Ruby's world opens up before us. The basic types we discussed -- integers, strings, floats, and variables -- form the foundation for the Ruby programming language. Now that we've learned about them, we can learn about some exciting new objects... and then eventually how to create new kinds of objects of our very own!</p>

<h3>Organizing Data</h3>

<p>We know now how we would put in numbers and letters in a Ruby program. But what if you want to organize them? Say you wanted to create a list of names, or perhaps you needed a dictionary of words. What would be the best way to do that?</p>

<p>That's what we'll discover now.</p>

<h3>Arrays</h3>

<p>Arrays are lists of objects. They look like this:</p>

<p><code>["This", "is", 'an', 'array', 123]</code></p>

<p>The brackets around the array are telling you what it is -- an array. The elements of the array are separated by commas. This array has five elements -- four strings and one integer. You can put any object into an array, and an array can be as big as you like. Just keep adding commas and elements inside the brackets until it's as big as you need.</p>

<p>Let's try some <strong>exercises</strong> to understand how to use arrays.</p>

<ol>
<li><p>Let's make a new array and assign it to a variable. Try <code>friends = []</code>. The empty brackets mean this is an empty array.</p></li>
<li><p>Let's learn some handy array methods. Try <code>friends.empty?</code> The sad truth is, presently we have no friends. We can verify that by trying <code>friends.count</code>, which, of course, is zero.</p></li>
<li><p>Being friendless sucks. Let's add a friend to our array. Try <code>friends.&lt;&lt;('tom')</code>. Now our array is <code>['tom']</code>. It has one element, the string 'tom'. The <code>&lt;&lt;</code> method inserts an object onto the end of an array. Because this syntax is used so frequently to add elements to an array, it has a shortcut. You can use <code>friends &lt;&lt; 'tom'</code> -- without the parenthesis or the dot -- in order to directly add an element to an array. This is very similar to the shortcut syntax for addition or subtraction (<code>1 + 1</code> instead of <code>1.+(1)</code>).</p></li>
<li><p>Let's add another friend. Try <code>friends.push('jimmy')</code>. Our friends list is certainly filling up! <code>push</code> and <code>&lt;&lt;</code> do the exact same thing to an array. They accept one argument -- the object to be inserted into the array -- and push it onto the very end.</p></li>
<li><p>When you count an array's elements in Ruby, you always start at zero. That is, the very first object in our array is object 0, not object 1. Let's see what that element is: use <code>friends[0]</code> to see the very first friend. Use <code>friends[1]</code> to see our second friend.</p></li>
<li><p>We can also access the elements of our array, instead of using the <code>[]</code> function, by using some English-soundung methods. Try <code>friends.first</code> to see our first friend, and <code>friends.last</code> to see our last.</p></li>
<li><p>This is all well and good, but let's say we have a fight with Tom and want to remove him from our friends array. Try <code>friends.delete('tom')</code>. The <code>delete</code> method removes every object that's identical to the provided argument, so if we had <code>'tom'</code> more than once in the array, all copies of him would be removed.</p></li>
</ol>


<p>Arrays are used commonly in Ruby to organize data in list format. Because they preserve ordering of their elements -- that is, the first element is always the first, the last element is always the last -- you can encode a lot of information in them and be confident of accessing it later.</p>

<h3>Hashes</h3>

<p>A hash is like a dictionary. In a dictionary, you look up a word -- say, 'zebra' -- and read a definition ('a big white and black striped horse-like animal'). Similarly, in a hash, you look up keys and receive values in return. A key is like the word 'zebra' in a dictionary: it's what you use to look up information in a hash. Values are the definitions: they're what you get back when you look up a word.</p>

<p>Hashes look like this:</p>

<p><code>{'mary' =&gt; 'little lamb', 'freddy' =&gt; 1, 'zebra' =&gt; 'a big white and black striped horse-like animal', 1 =&gt; 3}</code></p>

<p>Hashes are always contained in curly brackets, and each key has a hash rocket <code>=&gt;</code> that points to its value. They're very different from arrays, though: hashes have no internal ordering. In an array, we know the first element will always be first... but inside a hash, there's no guarantee that the element we just added will be the last. Let's try some <strong>exercises</strong> to explore this exciting new data structure.</p>

<ol>
<li><p>First, let's make a new hash and assign it to a variable. Try <code>dictionary = {'zebra' =&gt; 'animal'}</code>. If we provided an empty set of curly braces (<code>{}</code>), we'd have made a blank hash; instead we're starting it with an entry.</p></li>
<li><p>Let's look up a value in our hash. Try <code>dictionary['zebra']</code>. The square bracket notation here is similar to what we used earlier in arrays to look up elements; but here, when we look up an element in our hash, we have to provide the key name we stored it with. If we try <code>dictionary[0]</code>,</p></li>
<li><p>Adding a key and value to our hash is easy. Try <code>dictionary['peacock'] = 'beautiful'</code>. This assigns a new key -- 'peacock' -- to a new value -- 'beautiful'. We can look up that value by using <code>dictionary['peacock']</code>.</p></li>
<li><p>We can see an array of the keys in our hash with <code>dictionary.keys</code>, and an array of values with <code>dictionary.values</code>. Note, as I said earlier, that the ordering of elements in a hash is not preserved -- so the keys and values might not appear in the same positions you'd expect.</p></li>
<li><p>Keys have to be unique in a hash -- if you assign a value to a key that already exists, it will replace that key's existing value. Let's change the value of 'zebra'. Try <code>dictionary['zebra'] = 'striped'</code>. Now the value of 'zebra' is 'striped', instead of 'animal'.</p></li>
<li><p>Finally, data structures can contain other data structures. Let's add an array to our hash. Try <code>dictionary['other_animals'] = ['seahorse', 'human', 'eel']</code>.</p></li>
</ol>


<p>Hashes are a great format for storing information in a way that we want to quickly look up later. Whereas arrays are for lists of things, hashes are very much like dictionaries.</p>

<p>We'll look more at hashes and arrays later, when we discuss further how to manipulate data structures. But as of right now, we now know all the basic types in Ruby! It's time to use what we've learned to create our very first program.</p>

<h3>Our First Program</h3>

<p>We now know enough to write our very first program in Ruby! We need two methods we haven't discussed so far: <code>gets</code> and <code>puts</code>. <code>gets</code> grabs the next line of input from the command line; <code>puts</code> spits out whatever we tell it to the console. Let's use those methods to create a program that automatically tabulates points for us.</p>

<p>In Ruby, you write programs in a text editor. While on repl.it, the text editor is the left-half of the screen that we haven't really covered yet. When you write code in there, and press the 'play' button in the upper right, the code will be executed and you'll see the result on the right-hand side. Let's try entering this in to the text editor half of repl.it:</p>

<p>```ruby
scores ||= {}
puts 'Who just scored points?'
name = gets.chomp
puts 'How many more points did they get?'
points = gets.chomp</p>

<p>scores[name] = points
puts 'The current standings are: ' + scores.inspect
```</p>

<p>Let's dissect this progrma line-by-line to understand what's happening here.</p>

<p>In the first line, we create a hash called <code>scores</code>. The <code>||=</code> syntax only assigns the variable if it hasn't already been assigned: we'll cover how it works more in the next lesson.</p>

<p>In the second line, we ask the user who scored points.</p>

<p>In the third, we actually get the name from the command line. Input from the command line is usually terminated by a return -- but that return isn't helpful for us, so we use a string method called <code>chomp</code> to remove the new line from the end.</p>

<p>In the fourth and fifth lines, we again query the user and chomp their input.</p>

<p>The seventh line performs hash assignment, like we just learned: the score is inserted into the hash so that we can keep track of it.</p>

<p>And finally, in the fifth line, we output the actual scores. <code>inspect</code> returns a view of the object that's easily understandable to humans.</p>

<p>You can run this progrma multiple times. Every time you do, you can add in a new score to the hash; later we'll discover how to have the program automatically loop so that we don't have to keep running it manually.</p>

<h3>Your First Program</h3>

<p>Now that we know a little about Ruby, it's time for you to make your very first program all on your own!</p>

<p>Let's create a boss program. Have it ask you what your name is, and what your hobby is. Then use the string method <code>upcase</code> to have it yell back to you that you should get back to work doing that.</p>

<p>Next time, we'll learn how to control flow through our Ruby programs, and we'll start really digging into what makes the Ruby programming language so cool: enumerators!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Routing with Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails/"/>
    <updated>2012-05-22T23:08:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails</id>
    <content type="html"><![CDATA[<p>I love Rails' routing system. Quickly and easily connecting English-readable URLs to complicated web actions is one of the joys of working in one of the coolest web frameworks on the Internet. At Synthetic, we're ramping up to get a new site out, and as part of the push for that I implemented some cool dynamic routing. I wanted to briefly summarize how and why I went with the routing choices I did, to illustrate using routes expressively and, hopefully, easily.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Hipstamatic has gear. Lots and lots of gear. We have over 100 lenses, flashes, and films; but from a programmatic perspective they're all really similar -- they all have a name, a description, some assets associated to them... And so they're all lumped together in a single model called <code>Gear</code>. Our new application is intended to let users browse our entire gear collection, and so obviously it has a single controller that (surprise surprise) allows you to see each piece of gear. Thus we wind up with routes like this:</p>

<p><code>
  gear/alfred
  gear/dreampop
  gear/stache
</code></p>

<p>And that's kind of tragic. Each type of gear should have its own route, even if they're all in the same model. Something like this would be both more readable and more expressive:</p>

<p><code>
  lenses/alfred
  flashes/dreampop
  films/stache
</code></p>

<p>Of course, having a controller for each kind of gear would be crazy. Happily, Rails provides some easy routing solutions!</p>

<h2>The Solution</h2>

<p>In our routes.rb, for each kind of resource that we're expecting, we create matching routes:</p>

<p><code>ruby
[:lenses, :films, :flashes, :cases].each do |gear|
  match "#{gear}/:id", :controller =&gt; :gear, :action =&gt; :show, :type =&gt; gear, :as =&gt; gear
end
</code></p>

<p>Let's dissect this routing statement in two steps. For the first, obviously, we're linking a route like <code>lenses/a1</code> or <code>flashes/cherry</code> to the gear controller. Importantly we're also passing a type: either lenses, films, flashes, or cases, instructing the controller which endpoint we want. In said controller, we should make sure that this passed type and the name of the piece of gear match. Otherwise people would go to <code>lenses/dreampop</code> or <code>flashes/alfred</code> and still see the correct resource despite specifying an invalid type and name combination. That would just be madness!</p>

<p>```ruby
class GearController &lt; ApplicationController
  before_filter :find_gear</p>

<p>  private</p>

<p>  def find_gear</p>

<pre><code>@gear = Gear.type(params[:type].to_s.singularize).where(:reference =&gt; params[:id]).first if params[:id]
</code></pre>

<p>  end
end
```</p>

<p>Type is a named scope that matches the passed params[:type] to a database column storing the actual type of gear. So this will try to find a lens or flash or what have you with the appropriate reference name. Simple enough.</p>

<p>For the second part of the above route, the <code>:as =&gt; gear</code> part creates named routes like lenses_path and films_url. With that in mind, it's easy for us to dynamically generate links based only on the gear object. This is the helper that allows us to do so:</p>

<p><code>ruby
def multi_path(obj)
  self.send("#{obj.type.pluralize.downcase}_path".to_sym, obj.reference)
end
</code></p>

<p>So I can use <code>multi_path(Gear.find_by_name('Kaimal Mark II'))</code> and the route will be generated as if I had typed <code>lenses_path</code> instead of <code>multi_path</code>: similarly with any object that responds to type and reference, which happily for me is all gear. This is important because I don't want to have to use a switch in iterated blocks to figure out which path name I want to use. Now I can just use multi_path and be guaranteed that the correct one will be selected.</p>

<p>With only a few lines of code, it's easy to make routes that were previously clunky and unexpressive into sensible, readable endpoints. And you don't have to sacrifice DRY to do so. If you have a lot of data that's expressed through only one controller, consider dynamic routing like this. It's easier for customers to remember URLs that are readable to them, and this is a good way to make that happen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Programming I]]></title>
    <link href="http://joshsymonds.com/blog/2012/04/24/introduction-to-programming-i/"/>
    <updated>2012-04-24T12:04:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/04/24/introduction-to-programming-i</id>
    <content type="html"><![CDATA[<p>This is a copy of the handout I'll be giving to students for my upcoming class at the <a href="http://www.centeronhalsted.org/">Center on Halsted</a>, creatively titled "Introduction to Programming." It borrows structure rather liberally from Chris Pine's <a href="http://pine.fm/LearnToProgram">Learn to Program</a>, but the content is my own.</p>

<!-- more -->


<h2>Getting Started with Ruby</h2>

<h3>Welcome to Programming</h3>

<p>Computer programming is the skill that allows you to make computers do what you want. Computers are excellent at menial, repetitive tasks that require little oversight and no creativity: but you can also use them to make amazing websites, games, and applications. Whether it's a simple program to make your day-to-day life easier, or a complicated application that gives you full-time employment, computer programming is invaluable professionally and also rewarding personally. Even better, it's lots of fun!</p>

<p>Many people are intimidated by the idea of learning computer programming -- they're worried you need complicated math or lots of formal training to do well. Nothing could be further from the truth. Computer programming can be learned by anyone and is very much learning a new language. All you need to succeed at computer programming is familiarity with computers, a willingness to learn, and a computer to do the programming on.</p>

<p>You'll be learning computer programming through the computer language Ruby. Ruby was created with two goals in mind: productivity and fun. While easy to learn, it's also an extremely powerful programming language widely used in the professional world. Some of the most popular websites on the Internet were created with Ruby -- for example, Github, Hulu, and Twitter are all implemented in Ruby.</p>

<p>To learn Ruby, we'll be using an online tool that allows us to quickly and easily try Ruby, called <a href="http://repl.it">repl.it</a>. In our first <strong>exercise</strong>, we'll go to repl.it and type in an example expression.</p>

<ol>
<li><p>Open up your web browser.</p></li>
<li><p>In the address bar, type <code>repl.it</code>, and press enter.</p></li>
<li><p>Select Ruby (beta). A new window opens; on the right half of the screen you should see some information and a command prompt, and on the left half a blank white space for typing.</p></li>
<li><p>The right half of the screen is the Ruby console. Type <code>1 + 1</code> into it and press enter.</p></li>
</ol>


<p>The output of your command is returned to you immediately. Congratulations, you're a computer programmer!</p>

<h3>Numbers</h3>

<p>Computers are really excellent at math. In this <strong>exercise</strong>, we'll learn how to do math in Ruby.</p>

<ol>
<li><p>Try <code>2 * 3</code>. <code>*</code> is the multiplication operator.</p></li>
<li><p>Try <code>9 / 3</code>. <code>/</code> is the division operator.</p></li>
<li><p>Try <code>2+2</code>. You don't need spaces around the operator; in fact, Ruby doesn't care how many spaces appear in a statement.</p></li>
<li><p>Try <code>-9 - 3</code>. By putting a minus in front of a number, it becomes negative.</p></li>
<li><p>Try <code>9 / 0</code>. This is your first ever error message in Ruby. The kind of error appears before the colon (ZeroDivisionError, in this case); some helpful error text appears afterwards. Obviously, this error means you can't divide by zero.</p></li>
<li><p>Try <code>5 / 2</code>. It might surprise you that the result is 2 instead of 2.5; what's going on here?</p></li>
</ol>


<p>In Ruby, there are two kinds of numbers. There are <strong>integers</strong> -- that is, whole numbers, whether positive or negative -- and there are <strong>floats</strong>. Floats (short for "floating-point numbers") are numbers with any kind of decimal place, even if that decimal place is zero. <code>55.123</code>, <code>-231.4</code>, <code>0.001</code>, and <code>5.0</code> are all floats.</p>

<p>Most of the time, you'll be using integers. This is because most people (and thus most programs) deal in whole things: you don't receive 4.3 emails, or view 1.8 webpages, or listen to 5.24 of a song. Floats are used when you're doing more complicated mathematics, for example graphics or physics.</p>

<p>In this <strong>exercise</strong>, let's do some math on floats.</p>

<ol>
<li><p>Try <code>2.0 * 3.0</code>. Of course, the answer <code>6.0</code> is the same as the answer for integer math, <code>6</code>.</p></li>
<li><p>Try <code>5.0 / 2.0</code>. Now that answer looks a lot more like what we'd expect!</p></li>
<li><p>Try <code>-9.0 + 8.0</code>. Everything you would expect to work in integers works fine on floats.</p></li>
<li><p>Try <code>(598.0 / (92.0 - 90.0)) * 43.0 + 2.0</code>. Even complicated math is easy with computers!</p></li>
</ol>


<h3>Strings</h3>

<p>Numbers are exciting, but people generally use words a lot more than they do numbers. We refer to letters, words, and sentences in Ruby as <strong>strings</strong>. Strings in Ruby are always encapsulated by either single or double-quotes. In this <strong>exercise</strong>, we'll write a few strings to see how they work.</p>

<ol>
<li><p>Try <code>'Hello.'</code>. Notice that when Ruby returns a string to us, it's always in double quotes, even if we typed it in single quotes.</p></li>
<li><p>Try <code>"This is a big fancy string."</code>. Strings can be of any length and can contain any characters: spaces or punctuation included.</p></li>
<li><p>Try <code>'2 is my favorite number'</code>. Numbers that are in strings are just more words.</p></li>
<li><p>Try <code>'Well isn't this nice.'</code>. Oh no!</p></li>
<li><p>Try <code>"She said, "This is foolish!""</code> What's happening?</p></li>
</ol>


<p>You'll get a syntax error for the last two statements above. In both cases, Ruby is expecting a single quote or double quote to end the string, but instead we're using one inside the actual string itself. Ruby is only a computer language. Unlike a human reading either of those sentences, it can't tell which quotation marks are part of the sentence and which are intended to start and end the string; instead it gives us a syntax error.</p>

<p>Strings are fun to type, but they're even more fun to actually use! Let's do an <strong>exercise</strong> that shows us the power of strings.</p>

<ol>
<li><p>Try <code>'Hello' * 3</code>. Whoops, we probably wanted to put a space in there. Let's try it again with <code>'Hello ' * 3</code>. There, isn't that much better?</p></li>
<li><p>Try <code>'Message in ' + 'a bottle.'</code> Again, space is important.</p></li>
<li><p>Try <code>'12' * 3</code>. Is this different than what you'd expect?</p></li>
<li><p>Try <code>'12' + '12' + '12'</code>. How about that?</p></li>
</ol>


<p>The last two won't actually do math, like you might expect. Remember <code>'12'</code> is a string: <code>12</code> is an integer! So <code>'12'</code> is no different from <code>'sandwiches'</code> or <code>'love'</code> -- it's a word to Ruby, not a number. If you try to use strings as numbers, Ruby won't understand what you mean. Here's a quick <strong>exercise</strong> to illustrate this point.</p>

<ol>
<li><p>Try <code>'14' + 14</code>.</p></li>
<li><p>Try <code>3 * 'bacon'</code>.</p></li>
</ol>


<p>If you think about it, both of these errors make sense. What would it mean to add 14 to the word "fourteen?" How do you multiply three by bacon? Remember, computers can only do what you tell them. If you tell them to do things that don't make any sense, they'll return errors. Still, wouldn't it be nice to be able to add <code>'14'</code> to <code>14</code> and get 28, like we'd expect?</p>

<h3>Methods</h3>

<p>What do <code>1</code>, <code>"Hello"</code>, and <code>'My favorite number is 3'</code> all have in common? In Ruby, they're all objects. Ruby objects are very similar to real-world objects. Objects in Ruby can do things, just like objects you interact with every day. A car can drive, a cat can meow, and a person can smile. Objects in Ruby can do things as well; and the things that they can do are called <strong>methods</strong>.</p>

<p>In Ruby, you make an object perform a method with a period, and then the name of the method you want to call. So if you could use Ruby on your car, you would use <code>car.drive</code> to drive it, and if your cat wanted to meow, it would do <code>cat.meow</code>. Let's try a quick <strong>exercise</strong> to see how easy it is to use methods.</p>

<ol>
<li><p>Try <code>'Hello'.reverse</code>. reverse is a method for strings: it reverses the string for you. How helpful! In this example, 'Hello' is the object. The period instructs Ruby that a method is coming up next, and reverse is the name of the method.</p></li>
<li><p>Try <code>1.odd?</code>. Ruby tells you <code>true</code>, which obviously means that 1 is an odd number.</p></li>
<li><p>Try <code>1.zero?</code>. One is not zero, so Ruby returns <code>false</code>.</p></li>
<li><p>Try <code>'Sentence!'.length</code>. Length is a string method that returns how many characters are in that string.</p></li>
<li><p>Try <code>'I want to yell this'.upcase</code>. Upcase transforms a string into all capitals.</p></li>
</ol>


<p>There are dozens of possible methods for strings and numbers. Learning Ruby is very much like learning a new language -- while you will learn the grammar and the most commonly-used words in this class, you'll eventually want to grab a dictionary and look up more words yourself. Ruby's documentation contains a simple, complete, easy-to-read list of methods and is free online. There are instructions for finding it at the end of this handout.</p>

<p>Ruby tries to be as sensible as possible. Methods are named to be unsurprising and predictable. For example, if you know about <code>upcase</code>, you can guess that there's a similar method called <code>downcase</code> that does exactly the opposite -- that is, it would convert all letters into lowercase. And you'd be right!</p>

<p>Because Ruby tries very hard to be unsurprising, there are many methods with the same name between different kinds of objects. These methods generally do the same sorts of things. For example, strings and numbers both have a method that might look very familiar to you: the method <code>+</code>! Yes, you were already using methods without even realizing what they were. Try a quick <strong>exercise</strong> to prove it.</p>

<ol>
<li><p>Try <code>1.+(1)</code>.</p></li>
<li><p>Try <code>2.-(1)</code>.</p></li>
<li><p>Try <code>"One".+("One")</code>.</p></li>
</ol>


<p>The plus method is special. You don't need a period before it, but on almost all other methods, you do. It also acts differently for strings and numbers. On strings, <code>+</code> concatenates strings together. But on numbers, it actually adds them.</p>

<p>You might be wondering: what's with the parenthesis containing the 1 and "one"? That's an argument. An argument tells a method additional information it needs in order to perform its function. When you provide an argument (or arguments) to a method, you do so in a parenthesis after the method name itself. Let's do some quick <strong>exercises</strong> to see how methods accept arguments.</p>

<ol>
<li><p>Try <code>'hello'.delete('l')</code>. The argument to the <code>delete</code> method tells it which letter it should delete from the string.</p></li>
<li><p>Try <code>'space'.center(20)</code>. The argument to the <code>center</code> method tells the string how many spaces it should be centered in.</p></li>
<li><p>Try <code>'space'.center(20, '-')</code>. In Ruby, some methods accept more than one argument: each additional argument is separated with a comma. The second argument to <code>center</code> tells it what character to pad the string with. In this case, it gives us a lot of dashes.</p></li>
</ol>


<p>Unfortunately, not all methods are present on every object. Try this <strong>exercise</strong> to get a new, exciting Ruby error that you'll probably see a lot of: the <code>NoMethodError</code>.</p>

<ol>
<li><p>Try <code>1.reverse</code>. Whoops: <code>reverse</code> is a method for strings only.</p></li>
<li><p>Try <code>"Hello".odd?</code> Drat. Looks like <code>odd?</code> is only for numbers.</p></li>
<li><p>Try <code>"Hello".zero?</code> So is <code>zero?</code>.</p></li>
</ol>


<p>With the <code>NoMethodError</code>, Ruby is letting you know that a method you tried to call on an object didn't exist. You might have the wrong kind of object, or maybe you mistyped the method name. Whatever the case, this is Ruby's nice way of telling you that you messed up somewhere.</p>

<h3>Conversion</h3>

<p>Remember earlier how we thought it'd be nice if you could add <code>'14'</code> and <code>14</code> together to get 28? We now have all the ingredients to make this happen. Ruby has methods that convert one kind of object into another kind of object. In this <strong>exercise</strong>, we'll do some exciting conversions!</p>

<ol>
<li><p>Try <code>1.to_s</code>. to_s means "to string." Notice that the result comes back with quotation marks -- this isn't the number 1 anymore, but instead the word "1"!</p></li>
<li><p>Try <code>1.to_f</code>. to_f means "to float." The result is the number 1 as a float -- that is, 1.0.</p></li>
<li><p>Try <code>2.3.to_i</code>. to_i means "to integer." Because integers can only be whole numbers, the trailing .3 is dropped, converting the number to 2.</p></li>
<li><p>Try <code>'3'.to_i</code>. The word "3" is now the number 3.</p></li>
<li><p>Try <code>'14'.to_i + 14</code>. Pretty convenient, huh?</p></li>
<li><p>Try <code>'Hello'.to_i</code>.</p></li>
</ol>


<p>The result of that last one might surprise you. Ruby tries very hard to perform conversions sensibly, but when it can't convert a string, it'll return zero instead. So be careful of what you're trying to convert, or else you might get zero back instead.</p>

<h3>Next Session</h3>

<p>Now that we've covered the basics of Ruby, we'll put what we've learned into action. Using variables, we'll create our first Ruby programs, and finally make the computer work for us!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby in the Sandbox: SandRBox]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/31/ruby-in-the-sandbox-sandrbox/"/>
    <updated>2012-03-31T11:19:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/31/ruby-in-the-sandbox-sandrbox</id>
    <content type="html"><![CDATA[<p>I volunteer in the cyber center at the <a href="http://www.centeronhalsted.org/">Center on Halsted</a>. They're always looking for people to teach new classes, so I figured I would teach an introduction to programming class -- an introduction through Ruby. Besides being my favorite computer language, I think Ruby makes a great beginner's language: it has none of the strange, computer-oriented concepts that make most programming languages difficult to learn, and it even reads like pure, simple English. Instead of pointers and variable typing, you have sensible enumerators and object orientation. And also it's super fun.</p>

<p>Unfortunately, getting stuff installed on the computers at the cyber center is kind of a headache. Like most chronically underfunded but well-meaning institutions, there are about three levels of bureaucracy between you and getting anything done. And teaching Ruby without the aid of irb would be next to impossible. So what's a guy to do?</p>

<p>Simple: <a href="http://sandrbox.herokuapp.com/">create irb online</a>.</p>

<!-- more -->


<p>Now, I hear what you're saying: "Josh, that already exists, and it's called <a href="http://tryruby.org/">tryruby.org</a>!" Unfortunately, I don't like tryruby all that much. I have nothing but respect for their mission, but the service itself is achingly slow and frequently it won't work at all. I don't know what they're running it on (the only code I could find on github was months old), but I figured I could whip up something better.</p>

<p><a href="https://github.com/Veraticus/Sandrbox">Turns out I was right</a>. Sandrbox is a simple project that I'm actually pretty proud of; it makes use of some very edge-case metaprogramming concepts to create as secure an irb environment as I could whip up. In addition to removing dangerous methods on classes (and their metaclasses), it has some really nice syntactical sugar that makes it easy to understand where you are in a block. And when the execution of your secure code is done, it restores all the classes and methods that were missing while removing any new ones that were added, guaranteeing that your environment will be exactly the same as before you started executing code.</p>

<p>This is obviously important if you intend to run that code on a server somewhere -- after all, you can't have someone doing something like:</p>

<p><code>ruby
`killall -9 thin` # bad
Kernel.exec("rm -rf /") # worse
</code></p>

<p>These methods when executed in Sandrbox are instead gently sanitized:</p>

<p><code>ruby
Sandrbox.perform(['`killall -9 thin`']).output # =&gt; ["NameError: undefined local variable or method ``' for Kernel:Module"]
Sandrbox.perform(['Kernel.exec("rm -rf /")']).output # =&gt; ["NameError: undefined local variable or method `exec' for Kernel:Module"]
</code></p>

<p>While still allowing you to retain the power and complexity of Ruby:</p>

<p><code>ruby
Sandrbox.perform(['class Foo', 'def test', '"Hi!"', 'end', 'end', 'Foo.new.test']).output # =&gt; [nil, '"Hi!"']
</code></p>

<p>Even cooler is that it automatically does some parsing for you, so that you know when code can be executed or the user is probably not done yet typing:</p>

<p><code>ruby
response = Sandrbox.perform(['class Foo', 'def test'])
response.output # []
response.complete? # false
response.indent_level # 2
response.indent_character # 'def'
</code></p>

<p>I put a small Sinatra app in front of this and made a little site that I also called <a href="http://sandrbox.herokuapp.com/">Sandrbox</a>. I intend to use it in place of irb to teach this introduction to programming course -- it'll make a great tool for putting the power of Ruby in front of people while still being relatively assured that they can't destroy my server (intentionally or accidentally). And the code is really pretty neat, so you should definitely <a href="https://github.com/Veraticus/Sandrbox">check out the repository</a>. I can't say that it's totally secure yet, but it's a damn sight better than uncensored irb, and after a week or two of work I bet I'll be able to get it locked down pretty damn tight.</p>

<p>But until then, go ahead and try to break it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Delegation when Delegate Just Won't Work]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/28/delegation-when-delegate-just-wont-work/"/>
    <updated>2012-03-28T15:37:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/28/delegation-when-delegate-just-wont-work</id>
    <content type="html"><![CDATA[<p>Rails provides a really awesome ability to avoid <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a> violations -- the <a href="http://apidock.com/rails/Module/delegate">Module#delegate</a> method. The Law of Demeter is an informal programming guideline, intended to make your code more obvious and more reusable: objects should only call methods on other objects, not objects of those objects. To provide a more concrete example:</p>

<p><code>ruby
  @user.address.street_address # Law of Demeter violation: @user should not reach into address!
  @user.street_address # So much better...
</code></p>

<p>Rails, because it's cool, provides a quick and easy pattern for making this work:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :address
  delegate :street_address, :to => :address</p>

<p>end</p>

<p>User.new.street_address # Calls address.street_address
```</p>

<p>Check out the <a href="http://apidock.com/rails/Module/delegate">delegate documentation</a> for more information on how this functionality works. But <a href="http://stackoverflow.com/questions/9914400/delegate-all-method-calls-on-a-model-to-an-association">a question I came across on Stack Overflow</a> today asked: what do you when you want to delegate all methods? I do <a href="https://github.com/Veraticus/Dynamoid/blob/master/lib/dynamoid/adapter.rb#L122">something similar in Dynamoid</a> and wanted to talk about how to make this pattern sensible and performant.</p>

<!-- more -->


<p>Essentially you have two options when delegation fails: the easy but less performant way, and the hard but more performant way. It's always nice to have choices, right?</p>

<h2>The Easy Way</h2>

<p>The easy way uses <code>method_missing</code>. Method_missing, of course, is part of Ruby's extensive metaprogramming suite; it is called when a method that doesn't exist is invoked on an object. So, if you have an object (say our user from above) and you want to delegate all methods that it doesn't have itself to its address, you would simply do:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :address</p>

<p>  def method_missing(method, *args)</p>

<pre><code>return address.send(method, *args) if address &amp;&amp; address.respond_to?(method)
super
</code></pre>

<p>  end
end
```</p>

<p>This works and will correctly send every method that can be called on an address to that address. Unfortunately, method_missing is slower than defining a method directly on the object, so every time you're forced to use method_missing you're added fractions of milliseconds to your application. This speed difference is usually imperceptible, but you never know: if you use this method_missing enough it could make a difference.</p>

<h2>The Hard Way</h2>

<p>So we have the hard way. This method is "harder" only in that you need to know the methods you want to delegate beforehand -- in which case, why aren't you using <code>delegate</code>? There is still a use for this method though: if you want to do something like benchmarking or argument recording before you delegate, you can do that easily here.</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :address</p>

<p>  [:all, :my, :methods, :here].each do |m|</p>

<pre><code>define_method(m) do |*args|
  address.send(m, *args)
end 
</code></pre>

<p>  end</p>

<p>  end
```</p>

<p>In Dynamoid, we perform benchmarking in this method before sending the response along, allowing you to see how long the actual request took in DynamoDB.</p>

<p>Ultimately, you should use <code>delegate</code> if possible... but if it isn't, then either of these two options should get you started to avoid programming unpleasantness. Don't address your objects through other objects -- your code will look better and be more maintainable if you take some time to isolate methods!</p>
]]></content>
  </entry>
  
</feed>
