<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: beginner | Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/beginner/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-03-22T13:20:11-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Classifying and Refactoring Your Code]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code/"/>
    <updated>2012-03-16T00:39:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code</id>
    <content type="html"><![CDATA[<p>Outside of the guiding framework of Rails, it can be difficult to manage your own Ruby code, as I've discovered in the process of creating <a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a>. MVC provides a clear and concise framework that encapsulates the functionality of most web applications really well; but outside of web applications, exactly where and how to put your code is a lot less clear. I thought I'd share some of my experiences and thoughts on doing this in my own Gem in the hopes that the lessons I've learned will aid others.</p>

<!-- more -->


<h2>Hashes = Objects</h2>

<p>In the earlier iterations of Dynamoid, I was passing around almost everything in hashes, and the calculations I was performing on those hashes was growing more and more complicated as I went, with logic flying around my files like a flock of disorganized birds. When I was putting index logic into criteria chains, I realized that keeping indexes as hashes was an enormous mistake... and one I wish I had realized earlier.</p>

<p>As I was refactoring my code I realized that I pass hashes around in a number of places. Hashes work well initially to store small amounts of data, but if you're using them for that purpose you almost certainly want a real object instead. Just whip that hash apart into a class and you'll be surprised how much code will go in there, and how much simpler your application will be for your trouble.</p>

<h2>Refactor Early, Refactor Often</h2>

<p>I tend to be my own harshest critic, but honestly, my first pass at features tends to be messy at best. I make my tests pass (always test first, btw, but that's so fundamental I'm not going to include it as a point) but usually in the most complicated, slowest, unpleasant way possible. Take some time after the tests pass to stare at your code a bit and decide if that's really the best way to go about doing things. Usually a change will jump out at you immediately, but don't be afraid to just come back to the code later if nothing presents itself.</p>

<p>Tests allow you to do this kind of refactoring free of charge. I always imagine tests as the scaffolding around my code; no matter how tall the code gets, with the scaffolding it'll never fall over.</p>

<h2>Document!</h2>

<p>I'm really bad at this one myself, but I'm going to be going back through Dynamoid in the very near future and adding documentation to all my methods. Even if your code is a one-liner, people will read documentation over code every time. So document that code! Especially in a collaborative environment, documentation is critical for making your project easy to contribute to.</p>

<p>I'm sure other things will pop out at me after some thought, but these are the biggest takeaways Dynamoid has given me. Hopefully they'll be of use to someone else as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't Mess With Primary Keys]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/04/dont-mess-with-primary-keys/"/>
    <updated>2012-03-04T19:11:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/04/dont-mess-with-primary-keys</id>
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/users/1224374/veraticus">I really like answering questions on Stack Overflow</a> -- it's like a trivia game that you win by knowing Rails backwards and forwards, but instead of cheesy prizes you get awesome reputation points! And also little badges!</p>

<p>Recently I've been seeing a lot of beginner-style questions, and the most popular has definitely been some variant of "how do I mess with the primary key column?"</p>

<p>The answer is always, invariably, the same: don't.</p>

<!-- more -->


<p>It might seem sensible to tuck some sort of business logic away into your primary key. Just earlier today, <a href="http://stackoverflow.com/questions/9558715/changing-models-id-type-from-integer-to-decimal-makes-all-entries-try-to-be-0-0/9558832#9558832">I answered a question</a> from a guy who wanted to turn his primary key column into a decimal, and have the part before the decimal be equal to the primary key of another table -- so you'd have 75.001 and 75.002, with 75 being the primary key of the orders table. A cute idea for a new column like order_number or something like that, but just a plain awful idea for a primary key.</p>

<p>Primary keys, when you get right down to it, are database artifacts. They're useful because they allow databases to expose powerful relations for our data: without a way for databases to reference individual rows that are guaranteed to be unique, even the most basic joins would be impossible. And because they're important for databases, the assumption seems to be that they're important for people too.</p>

<p>Part of this is Rails' fault. By exposing URLs with primary keys by default (like users/4), one would automatically assume that the primary key is important data for a user to know (your key is 4 and that's important!). In reality nothing could be further from the truth: the ID for a user is arbitrary database-internal logic and has no business facing users at all. I wish Rails going forward came bundled with the really awesome <a href="https://github.com/norman/friendly_id">FriendlyId</a> Gem that makes some unique database column appear to your internal application logic as the real ID for that table. Then you'd have URLs like users/josh, and that both looks better and obfuscates the primary key.</p>

<p>As a sidenote, this is why UUID-based keys like <a href="http://www.mongodb.org/display/DOCS/Object+IDs">MongoDB's</a> and <a href="https://github.com/Veraticus/Dynamoid">Dynamoid's</a> are rather nifty -- they make really ugly ID-based URLs by default so force you to choose a better column to use as a URL slug.</p>

<p>The problem with all this attention on the primary key is that, invariably, people want to change it. Changing primary keys is awful. It will disassociate data all throughout your database, it messes with table autoincrementing... it will lead to problems right at the moment, and even more down the road you won't even foresee. Or even worse, you'll want to choose something nonstandard as a primary key (or not choose one at all) -- and you'll want to perform a join and be forced to deal with the consequences of your decision. Hint: they won't be pretty.</p>

<p>So do yourself a favor. View the ID column as what it really is: an internal database construction. It should be an auto-incrementing integer, no excuses. If you want any kind of business logic, make a new column for it and manage it separately. You'll be glad you did, I promise.</p>
]]></content>
  </entry>
  
</feed>
