<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-07-04T17:25:12-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Concerns II: Taggable]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable/"/>
    <updated>2012-07-04T15:31:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable</id>
    <content type="html"><![CDATA[<p>For the second part of my series on Rails concerns (following <a href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/">part one earlier this week</a>), I'll be dissecting a tagging system and how to make it concerned. Of course, you have great gems like <a href="https://github.com/mbleigh/acts-as-taggable-on/">acts-as-taggable-on</a>, but if you want significant customized functionality in either your Tag class or the taggables, you're going to have to roll your own solution. That's what I'm doing for GirlsGuideTo, and this is how I implemented it.</p>

<!-- more -->


<h2>The Tag Model</h2>

<p>The tag model itself is fairly straightforward:</p>

<p>```ruby
class Tag &lt; ActiveRecord::Base
  has_many :taggings</p>

<p>  has_many :addresses, through: :taggings, source: :taggable, source_type: Address
  has_many :users, through: :taggings, source: :taggable, source_type: User
end
```</p>

<p>Unfortunately, you can't just say <code>belongs_to :taggable, through: :taggings</code>. Polymorphic has-and-belongs-to-many associations don't work, since they have no real table to select from. To illustrate this concept, consider the <code>Tag</code> model above: if you had a line like <code>belongs_to :taggable</code> and called <code>tag.taggables</code>, what would be returned? Theoretically an array of objects, but the objects would be of all different sorts: some would be addresses, some would be users. And how would they be grabbed from the database? You can't <code>SELECT * from taggables</code>, since there is no taggables table.</p>

<p>This is frustrating, but easy enough to work around. You'll have to specify every model that's taggable in the <code>Tag</code> class. But since we'll be employing a concern here, we know that all of the taggable classes will respond the same way. Thus, if you're confident, you can define a taggables method yourself:</p>

<p>```ruby
  def taggables</p>

<pre><code>[addresses + users].flatten
</code></pre>

<p>  end
```</p>

<p>Whether or not you decide to do this is up to you. I would recommend against it since likely you'll want to display the different kinds of taggables in different places anyway.</p>

<h2>The Join Model</h2>

<p>Tag has-and-belongs-to-many taggables through a join model. That model is <code>Tagging</code>, and should look like this:</p>

<p>```ruby
class Tagging &lt; ActiveRecord::Base
  attr_accessible :tag_id, :taggable_id, :taggable_type</p>

<p>  belongs_to :tag
  belongs_to :taggable, :polymorphic => true
end
```ruby</p>

<p>There's nothing particularly surprising here. Just remember to set the <code>taggable</code> to polymorphic or Rails won't fill in the association correctly.</p>

<h2>The Taggable Concern</h2>

<p>Finally, we can get to the concern itself. This is how I've set it up:</p>

<p>```ruby
module Taggable
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>has_many :taggings, :as =&gt; :taggable
has_many :tags, :through =&gt; :taggings
</code></pre>

<p>  end</p>

<p>  def tag(name)</p>

<pre><code>name.strip!
tag = Tag.find_or_create_by_name(name)
self.taggings.find_or_create_by_tag_id(tag.id)
</code></pre>

<p>  end</p>

<p>  def tag_names</p>

<pre><code>tags.collect(&amp;:name)
</code></pre>

<p>  end
end
```</p>

<p>This uses a new feature of concerns: the <code>included</code> statement. Anything inside this block will be executed by the including class when the inclusion occurs. In this case, we'll be including this concern in multiple ActiveRecord models -- and those models will automatically <code>has_many</code> :taggings and :tags.</p>

<p>And on those models we'll be able to do some neat stuff. We can automatically add a tag just by calling <code>model.tag("tag_name")</code>: if it didn't exist before, it will automatically be created, and then it'll be added to the model's taggings. Also we can get a handy array of all the names of tags for a model. This is just the start of the functionality you can employ, though. Taggable would be a sensible place to put tag cloud creation and tagging contexts, if you wanted to ape more functionality from acts-as-taggable-on while still retaining your own customized implementations.</p>

<p>Next time I discuss concerns, I'll talk about an ActionController concern to improve your page's SEO and Facebook Graph integration. It'll be pretty awesome, so stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns I: Starting with Redcarpet]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/"/>
    <updated>2012-07-01T20:32:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet</id>
    <content type="html"><![CDATA[<p>Rails concerns are a fancy way of saying Ruby modules. 37signals uses concerns <a href="http://37signals.com/svn/posts/3167-code-spelunking-in-the-all-new-basecamp">a lot in the new Basecamp</a>, and it's easy to see why: separation and recatoring allow you to reuse code more sensibly and test it in only one place. But concerns aren't only for code refuse -- by allowing you to unclutter models, they make it more obvious where code in your application lives. Even though, for example, orders are the only model in your system being shipped, having a concern called Shipping makes it completely obvious that that's where all the functionality for shipping lies... whereas a newcomer to your application would have to search through the order model to find it.</p>

<p>I've been using concerns extensively in GirlsGuideTo's upcoming application, and I figured it'd be an interesting read if I shared the ones I've made so far. They're not too complicated (this first one I'm posting mostly just to illustrate the concept), but but don't let that fool you. They can be super complicated and really involved -- but more than that, concerns just make your code better, so you should definitely be using them!</p>

<!-- more -->


<h2>Redcarpeted</h2>

<p>A lot of fields in GirlsGuideTo are Markdown encoded by the pretty awesome <a href="https://github.com/tanoku/redcarpet/">Redcarpet</a> gem. These fields occur across models, and rather than copy and paste code all over the place, I extracted the idea of converting fields to and from Markdown into a concern.</p>

<p>```ruby
module Redcarpeted
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def redcarpet(field)
  define_method("#{field}_markdown".to_sym) do
    read_attribute(field)
  end

  define_method("#{field}_html".to_sym) do
    Redcarpet.new(read_attribute(field)).to_html
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ActiveSupport::Concern</code> is the magic that makes concerns so ... magical. Simply by including another module called <code>ClassMethods</code>, <code>ActiveSupport::Concern</code>automatically knows to extend the base class with those methods when it's included.</p>

<p>In this case, this allows you to do something like this in your model:</p>

<p>```ruby
  class Post &lt; ActiveRecord::Base</p>

<pre><code>include Redcarpeted

redcarpet :body
</code></pre>

<p>  end
```</p>

<p>Now your Post has two new methods: <code>body_markdown</code> and <code>body_html</code>, allowing you to quickly and easily access the raw Markdown and formatted HTML for any attribute in your model. (And if you're curious, the reason to bother including a <code>body_markdown</code> method is in case you decide to override the base method <code>body</code> yourself at some future point.)</p>

<p>That's just the starts of Rails concerns, though. Next time I'll post a more complicated example with greater ActiveRecord connectivity that will hopefully be a lot more exciting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/"/>
    <updated>2012-06-28T15:09:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages</id>
    <content type="html"><![CDATA[<p>One of the coolest features of Rails 3.2 is <a href="http://api.rubyonrails.org/classes/ActiveSupport/TaggedLogging.html">tagged logging</a>. Using the UUID tagged logger, you can give each individual request a UUID reference number in order to track individual errors, find them, and smoosh them. It's generally pretty awesome.</p>

<p>But it'd be even awesomer if actual errors in your application referenced this UUID, wouldn't it? Maybe even emailed it to you in exception_notification? Presented it to your users so they could say directly, "I encountered error 123xyz," rather than force you to look through a huge amount of backlog to find their specific exception?</p>

<p>Happily, you can do just this!</p>

<!-- more -->


<h2>Rescue_from Madness</h2>

<p>Doing so requires abusing rescue_from a little bit, though. Set up something like this in your application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from ActionController::UnknownAction, with: :render_404
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>This will prevent any error from rendering the default Rails error pages. Instead we'll set up our own error pages like so:</p>

<p>```ruby
  def render_500(exception)</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message
Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
Rails.logger.fatal exception.backtrace.join("\n")
render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>And finally, in your view, actually include the request's unique identifier:</p>

<p><code>ruby
  &lt;h1&gt;&lt;%= @message.split(/\s/).collect(&amp;:capitalize).join(' ') %&gt; &lt;small&gt;&lt;%= @status %&gt;&lt;/small&gt;&lt;/h1&gt;
  &lt;h3&gt;Error Code: &lt;%= request.env['action_dispatch.request_id'] %&gt; &lt;/h3&gt;
</code></p>

<p>Dynamic error pages like what I'm suggesting are powerful but also dangerous. Static error pages are simpler and more maintainable: if the code executing your error page has an error in it, then your server process will loop until finally throwing a system stack exception. But if you keep your dynamic error pages simple and well-tested, it's pretty unlikely that'll happen. Just be careful when using this system -- maybe even don't render the exception in your usual layout, but render it in an error-specific one -- to reduce the chance of your error pages also erroring, and you'll be golden.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing Sites for Users]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users/"/>
    <updated>2012-06-17T17:52:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users</id>
    <content type="html"><![CDATA[<p>Designing a new site from scratch can be difficult -- not technically, but from a usability perspective. What color will your users like best? How big should your buttons be? Where should advertising be placed? Of course, there are <a href="http://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758">amazing usability books</a> out there, but there are some questions you can only answer through experience. Of course, designing for usability should be one of our top priorities -- and here are three cute little libraries that will help you make your sites awesome, beautiful, and most importantly, usable for your users.</p>

<!-- more -->


<h2>Mailcheck</h2>

<p>The amazing <a href="https://github.com/Kicksend/mailcheck">Mailcheck</a> library is great for any site that accepts email addresses. According to its creators, <a href="http://kicksend.com">Kicksend</a>, <a href="http://blog.kicksend.com/how-we-decreased-sign-up-confirmation-email-bounces-by-50/">Mailcheck reduced email confirmation signup bounces by 50%</a>. Now that's pretty impressive.</p>

<p>I also love Mailcheck's philosophy. The guiding idea here -- that users will make errors, and software should respond efficiently to correct them -- is true no matter what you're making, from an iPhone app to a website. Always remember that users will improperly use your software. Guiding them back to the appropriate path is your responsibility, with libraries like Mailcheck specifically, but also generally through your app's flow and and user experience. Every form field that encounters frequent errors should have a Mailcheck-like check around it; your users will thank you by loving your app even more.</p>

<h2>Chosen</h2>

<p><a href="https://github.com/harvesthq/chosen">Chosen</a> is cute little syntactical sugar that turns select boxes from ugly, long monstrosities into helpful little widgets. Check out the <a href="https://github.com/harvesthq/chosen">sample page</a> to see everything that it can do; if you have a select box on your site (and chances are that you do), then you should be using Chosen to help users select items from it more effectively.</p>

<p>Chosen expresses another important usability concept -- accessibility. Modern software can be ridiculously complicated, but most users don't care at all for complexity: they want information presented to them clearly, and they want to be able to navigate said information sensibly. By turning enormous select lists into hinting dropdowns, Chosen formats information sensibly and allows users to select what they want quickly. Ideal accessibility from a user's perspective.</p>

<h2>Bandit</h2>

<p>There's been a fair amount of <a href="http://www.chrisstucchio.com/blog/2012/bandit_algorithms_vs_ab.html">discussion</a> recently about the <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>, especially as it relates to A/B testing. I've done A/B testing with Rails before but never really enjoyed it; but I recently came across the <a href="https://github.com/bmuller/bandit">bandit</a> gem and I know I'll be using it extensively moving into the future.</p>

<p>Using multi-armed bandit solutions, you can test lots of options at once, and for as long as you like. Gradually the numbers for the test will reflect the reality of user preference: you don't need a set number of tests (as per A/B testing) and you aren't confined to only two options. Ultimately, you don't need to guess what a user wants. You can make some reasonable guesses and set them all up as possibilities, and over time, user choice will guide the direction of your site. And that's pretty awesome.</p>

<p>In the end, usability is about making your software more responsive and more presentable to your audience. Try out these libraries, but more than that, keep in mind the principles that guide them. By following those, you're guaranteed to make software that's much more usable than it would be otherwise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Routing with Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails/"/>
    <updated>2012-05-22T23:08:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails</id>
    <content type="html"><![CDATA[<p>I love Rails' routing system. Quickly and easily connecting English-readable URLs to complicated web actions is one of the joys of working in one of the coolest web frameworks on the Internet. At Synthetic, we're ramping up to get a new site out, and as part of the push for that I implemented some cool dynamic routing. I wanted to briefly summarize how and why I went with the routing choices I did, to illustrate using routes expressively and, hopefully, easily.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Hipstamatic has gear. Lots and lots of gear. We have over 100 lenses, flashes, and films; but from a programmatic perspective they're all really similar -- they all have a name, a description, some assets associated to them... And so they're all lumped together in a single model called <code>Gear</code>. Our new application is intended to let users browse our entire gear collection, and so obviously it has a single controller that (surprise surprise) allows you to see each piece of gear. Thus we wind up with routes like this:</p>

<p><code>
  gear/alfred
  gear/dreampop
  gear/stache
</code></p>

<p>And that's kind of tragic. Each type of gear should have its own route, even if they're all in the same model. Something like this would be both more readable and more expressive:</p>

<p><code>
  lenses/alfred
  flashes/dreampop
  films/stache
</code></p>

<p>Of course, having a controller for each kind of gear would be crazy. Happily, Rails provides some easy routing solutions!</p>

<h2>The Solution</h2>

<p>In our routes.rb, for each kind of resource that we're expecting, we create matching routes:</p>

<p><code>ruby
[:lenses, :films, :flashes, :cases].each do |gear|
  match "#{gear}/:id", :controller =&gt; :gear, :action =&gt; :show, :type =&gt; gear, :as =&gt; gear
end
</code></p>

<p>Let's dissect this routing statement in two steps. For the first, obviously, we're linking a route like <code>lenses/a1</code> or <code>flashes/cherry</code> to the gear controller. Importantly we're also passing a type: either lenses, films, flashes, or cases, instructing the controller which endpoint we want. In said controller, we should make sure that this passed type and the name of the piece of gear match. Otherwise people would go to <code>lenses/dreampop</code> or <code>flashes/alfred</code> and still see the correct resource despite specifying an invalid type and name combination. That would just be madness!</p>

<p>```ruby
class GearController &lt; ApplicationController
  before_filter :find_gear</p>

<p>  private</p>

<p>  def find_gear</p>

<pre><code>@gear = Gear.type(params[:type].to_s.singularize).where(:reference =&gt; params[:id]).first if params[:id]
</code></pre>

<p>  end
end
```</p>

<p>Type is a named scope that matches the passed params[:type] to a database column storing the actual type of gear. So this will try to find a lens or flash or what have you with the appropriate reference name. Simple enough.</p>

<p>For the second part of the above route, the <code>:as =&gt; gear</code> part creates named routes like lenses_path and films_url. With that in mind, it's easy for us to dynamically generate links based only on the gear object. This is the helper that allows us to do so:</p>

<p><code>ruby
def multi_path(obj)
  self.send("#{obj.type.pluralize.downcase}_path".to_sym, obj.reference)
end
</code></p>

<p>So I can use <code>multi_path(Gear.find_by_name('Kaimal Mark II'))</code> and the route will be generated as if I had typed <code>lenses_path</code> instead of <code>multi_path</code>: similarly with any object that responds to type and reference, which happily for me is all gear. This is important because I don't want to have to use a switch in iterated blocks to figure out which path name I want to use. Now I can just use multi_path and be guaranteed that the correct one will be selected.</p>

<p>With only a few lines of code, it's easy to make routes that were previously clunky and unexpressive into sensible, readable endpoints. And you don't have to sacrifice DRY to do so. If you have a lot of data that's expressed through only one controller, consider dynamic routing like this. It's easier for customers to remember URLs that are readable to them, and this is a good way to make that happen.</p>
]]></content>
  </entry>
  
</feed>
