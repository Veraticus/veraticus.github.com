<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-07-04T14:06:28-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails is the Most American Framework (and PHP is the Least)]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/04/rails-is-the-most-american-framework-and-php-is-the-least/"/>
    <updated>2012-07-04T12:26:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/04/rails-is-the-most-american-framework-and-php-is-the-least</id>
    <content type="html"><![CDATA[<p><a href="http://joshsymonds.com/blog/2012/05/04/why-rubymotion-is-better-than-objective-c/">I'm no stranger to controversy.</a> I'm not afraid to stand up and say what millions of coders already know -- but what most people don't know is that I'm also extremely patriotic.</p>

<p><img src="http://f.cl.ly/items/1V0z0n1Z3C3Q101I0I3z/boldly_french.jpg" alt="Boldly patriotic" /></p>

<p>That's me, boldly pointing the way into the brighter, awesomer future of America. As I was sitting down to write the next in my series of <a href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/">concerns on Rails</a>, my boyfriend (who is also a die-hard, red-blooded, Commie-hating patriot) suggested that I marry my love of Rails code and my love of the US of A in a very special blog post.</p>

<p>But a post like that -- as daringly insightful as it might be -- just wouldn't be good enough for this blog. You see, my posts are also highly topical, and everyone knows Rails and America go together like chocolate and peanut butter. Pointing that out wouldn't really be exciting or new. I needed a special sauce to truly set my contribution apart: and that's when I remembered that a lot has been said recently about how <a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">horrible</a>/<a href="http://fabien.potencier.org/article/64/php-is-much-better-than-what-you-think">wonderful</a> PHP is.</p>

<p>For I have a unique insight that no one else has ever considered in this debate: I know for a fact that Rails is easily the most American framework in existence, and PHP is the least. Thus I have at last resolved this tedious debate. PHP is indeed awful, and possibly also sponsored by the Axis of Evil, and Rails is as American as apple pie and the colors red, white, and blue. How did I arrive at this conclusion? Really, it's just common sense, but if you're not patriotic enough to figure it out I've helpfully included my reasoning.</p>

<!-- more -->


<h2>Rails is the Most American Framework</h2>

<p>In order to examine Rails' blindingly obvious American-ness, we need a sensible rubric. How do you say one thing is more American than another? Well, I've helpfully come up with a completely objective barometer of Americana. Everyone would agree that the three core tenents of the United States are freedom, liberty, and database agnosticism -- so what better ways than those to rate Rails itself?</p>

<h3>Freedom &amp; Liberty</h3>

<p>One of Rails' core features is freedom. I know this is true because it was built that way by <a href="http://en.wikipedia.org/wiki/David_Heinemeier_Hansson">David Heinemeyer Hansson</a>, who is perhaps the most real and most original of American patriots.</p>

<p><img src="http://4.bp.blogspot.com/-aLryA2Bey-w/TY6usViKtAI/AAAAAAAACiE/B2qQeW_ags0/s1600/heinemeier.article.jpg" alt="The man himself" /></p>

<p>DHH is a Danish programmer, and Denmark is pretty close to France, which is very American because the Frenchman Napoleon sold Lousiana to America in 1803. So he's definitely included in the American cultural halo effect, making him a United States citizen from the moment he was born.</p>

<p>But even more importantly than that, I have inside knowledge that David (we're on a first name basis) is working on a "Men of 37signals" beefcake calendar. Nothing is more American than men baring nearly everything for money, and indeed, nothing represents liberty more than successful entrepreneurs stripping for petty cash.</p>

<h3>Liberty &amp; Database Agnosticism</h3>

<p>Really I think this point needs no explanation. But here's one anyway: when the framers of our Constitution wrote in that that hallowed document, "it becomes necessary for one people to dissolve the political bands which have connected them with another," they were doing more than obliquely referencing the creation of Rails nearly 200 years later. They were talking about dissolving the ties connecting an application to its database.</p>

<p>They were <em>liberating</em> the Internet from the cruel confines of the databases that constrained it.</p>

<p>Using object-relational mapping like ActiveRecord, document-relational mapping like Mongoid, or even document-relational mapping like the far superior <a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a> is the true fulfillment of this centuries-old promise. This more than anything else represents Americanism: true, real liberty. Liberty you can touch, if you wanted to print out the source code and rub it all over your body.</p>

<p>Which is what any real American would do.</p>

<h2>PHP is the Work of Evil</h2>

<p>Obviously, since Rails is a framework and PHP is a language, comparing the two is like comparing red apples to green apples. And that metaphor is even more apt here -- because PHP is indeed very red. And by that I mean Communist. But examining PHP's socialist leanings is fruitless: everyone knows there's greater evils than socialism in the world. The greatest of American leaders helpfully enumerated them for us.</p>

<p><img src="http://3.bp.blogspot.com/-GNEL1sdGcvA/T0xJfvragjI/AAAAAAAAEF0/t5Nuvs6IEoA/s1600/George-W.-Bush.jpg" alt="Greatest American Leader" /></p>

<p>They are Iran, Iraq, and North Korea.</p>

<h3>Iran &amp; Iraq</h3>

<p>Damningly, Iran and Iraq share a subcontintent with the country in which Zend Technologies itself is founded -- Israel. Just as the American freedom effect haloed DHH into citizenship, the evil anti-halo effect condemns Zend and everything it's created, which includes PHP. As a Jew who has visited Israel twice, I know this to be the case since I've seen it with my very own eyes. And nothing beats anecdotal evidence.</p>

<p>Iran and Iraq also share numerous letters in their names with the worst perpetrator of PHP on the planet: India. (I'm counting the "i"s twice, so they have more letters in common than they ordinarily might.) Lots of Indians program PHP, and thus we can safely say many of India's most awesome works of art were created with PHP. The fact that other countries can make things that are arguably better than what American's done is inherently anti-American. For example:</p>

<p><img src="http://www-bgr-com.vimg.net/wp-content/uploads/2011/03/india110314124035.jpg" alt="Created with PHP" /></p>

<p>Just looking at that makes me sick.</p>

<h3>North Korea</h3>

<p>But I think North Korea deserves its own, special callout. The only PHP programmer I personally know is Korean. He also bears more than a passing resemblance to Kim Jong-un.</p>

<p><img src="http://www.csmonitor.com/var/ezflow_site/storage/images/media/content/2012/0415/0415_kim_jong_un/12281745-1-eng-US/0415_Kim_jong_un_full_600.jpg" alt="This is him" /></p>

<p>Kim Jong-un is the latest in a line of horrible, hereditary dictators that ruthlessly oppress their people. Doesn't that sound familiar to you, PHP programmers? Because if it doesn't, it should. It's the heart of what being American isn't -- just like PHP itself.</p>

<h2>What does this mean for you?</h2>

<p>I think the answer to my rhetorical question here is pretty obvious. But if you really need all this boiled down for you -- maybe because you're a PHP programmer and you're too busy hating America to have real reading comprehension -- here it is:</p>

<p><em>You should totally be buying the "Men of 37signals" calendar</em>. I hear Mr. July is super hot.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns I: Starting with Redcarpet]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/"/>
    <updated>2012-07-01T20:32:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet</id>
    <content type="html"><![CDATA[<p>Rails concerns are a fancy way of saying Ruby modules. 37signals uses concerns <a href="http://37signals.com/svn/posts/3167-code-spelunking-in-the-all-new-basecamp">a lot in the new Basecamp</a>, and it's easy to see why: separation and recatoring allow you to reuse code more sensibly and test it in only one place. But concerns aren't only for code refuse -- by allowing you to unclutter models, they make it more obvious where code in your application lives. Even though, for example, orders are the only model in your system being shipped, having a concern called Shipping makes it completely obvious that that's where all the functionality for shipping lies... whereas a newcomer to your application would have to search through the order model to find it.</p>

<p>I've been using concerns extensively in GirlsGuideTo's upcoming application, and I figured it'd be an interesting read if I shared the ones I've made so far. They're not too complicated (this first one I'm posting mostly just to illustrate the concept), but but don't let that fool you. They can be super complicated nad really involved -- but more than that, concerns just make your code better, so you should definitely be using them!</p>

<!-- more -->


<h2>Redcarpeted</h2>

<p>A lot of fields in GirlsGuideTo are Markdown encoded by the pretty awesome <a href="https://github.com/tanoku/redcarpet/">Redcarpet</a> gem. These fields occur across models, and rather than copy and paste code all over the place, I extracted the idea of converting fields to and from Markdown into a concern.</p>

<p>```ruby
module Redcarpeted
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def redcarpet(field)
  define_method("#{field}_markdown".to_sym) do
    read_attribute(field)
  end

  define_method("#{field}_html".to_sym) do
    Redcarpet.new(read_attribute(field)).to_html
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ActiveSupport::Concern</code> is the magic that makes concerns so ... magical. Simply by including another module called <code>ClassMethods</code>, <code>ActiveSupport::Concern</code>automatically knows to extend the base class with those methods when it's included.</p>

<p>In this case, this allows you to do something like this in your model:</p>

<p>```ruby
  class Post &lt; ActiveRecord::Base</p>

<pre><code>include Redcarpeted

redcarpet :body
</code></pre>

<p>  end
```</p>

<p>Now your Post has two new methods: <code>body_markdown</code> and <code>body_html</code>, allowing you to quickly and easily access the raw Markdown and formatted HTML for any attribute in your model. (And if you're curious, the reason to bother including a <code>body_markdown</code> method is in case you decide to override the base method <code>body</code> yourself at some future point.)</p>

<p>That's just the starts of Rails concerns, though. Next time I'll post a more complicated example with greater ActiveRecord connectivity that will hopefully be a lot more exciting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/"/>
    <updated>2012-06-28T15:09:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages</id>
    <content type="html"><![CDATA[<p>One of the coolest features of Rails 3.2 is <a href="http://api.rubyonrails.org/classes/ActiveSupport/TaggedLogging.html">tagged logging</a>. Using the UUID tagged logger, you can give each individual request a UUID reference number in order to track individual errors, find them, and smoosh them. It's generally pretty awesome.</p>

<p>But it'd be even awesomer if actual errors in your application referenced this UUID, wouldn't it? Maybe even emailed it to you in exception_notification? Presented it to your users so they could say directly, "I encountered error 123xyz," rather than force you to look through a huge amount of backlog to find their specific exception?</p>

<p>Happily, you can do just this!</p>

<!-- more -->


<h2>Rescue_from Madness</h2>

<p>Doing so requires abusing rescue_from a little bit, though. Set up something like this in your application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from ActionController::UnknownAction, with: :render_404
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>This will prevent any error from rendering the default Rails error pages. Instead we'll set up our own error pages like so:</p>

<p>```ruby
  def render_500(exception)</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message
Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
Rails.logger.fatal exception.backtrace.join("\n")
render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>And finally, in your view, actually include the request's unique identifier:</p>

<p><code>ruby
  &lt;h1&gt;&lt;%= @message.split(/\s/).collect(&amp;:capitalize).join(' ') %&gt; &lt;small&gt;&lt;%= @status %&gt;&lt;/small&gt;&lt;/h1&gt;
  &lt;h3&gt;Error Code: &lt;%= request.env['action_dispatch.request_id'] %&gt; &lt;/h3&gt;
</code></p>

<p>Dynamic error pages like what I'm suggesting are powerful but also dangerous. Static error pages are simpler and more maintainable: if the code executing your error page has an error in it, then your server process will loop until finally throwing a system stack exception. But if you keep your dynamic error pages simple and well-tested, it's pretty unlikely that'll happen. Just be careful when using this system -- maybe even don't render the exception in your usual layout, but render it in an error-specific one -- to reduce the chance of your error pages also erroring, and you'll be golden.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing Sites for Users]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users/"/>
    <updated>2012-06-17T17:52:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users</id>
    <content type="html"><![CDATA[<p>Designing a new site from scratch can be difficult -- not technically, but from a usability perspective. What color will your users like best? How big should your buttons be? Where should advertising be placed? Of course, there are <a href="http://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758">amazing usability books</a> out there, but there are some questions you can only answer through experience. Of course, designing for usability should be one of our top priorities -- and here are three cute little libraries that will help you make your sites awesome, beautiful, and most importantly, usable for your users.</p>

<!-- more -->


<h2>Mailcheck</h2>

<p>The amazing <a href="https://github.com/Kicksend/mailcheck">Mailcheck</a> library is great for any site that accepts email addresses. According to its creators, <a href="http://kicksend.com">Kicksend</a>, <a href="http://blog.kicksend.com/how-we-decreased-sign-up-confirmation-email-bounces-by-50/">Mailcheck reduced email confirmation signup bounces by 50%</a>. Now that's pretty impressive.</p>

<p>I also love Mailcheck's philosophy. The guiding idea here -- that users will make errors, and software should respond efficiently to correct them -- is true no matter what you're making, from an iPhone app to a website. Always remember that users will improperly use your software. Guiding them back to the appropriate path is your responsibility, with libraries like Mailcheck specifically, but also generally through your app's flow and and user experience. Every form field that encounters frequent errors should have a Mailcheck-like check around it; your users will thank you by loving your app even more.</p>

<h2>Chosen</h2>

<p><a href="https://github.com/harvesthq/chosen">Chosen</a> is cute little syntactical sugar that turns select boxes from ugly, long monstrosities into helpful little widgets. Check out the <a href="https://github.com/harvesthq/chosen">sample page</a> to see everything that it can do; if you have a select box on your site (and chances are that you do), then you should be using Chosen to help users select items from it more effectively.</p>

<p>Chosen expresses another important usability concept -- accessibility. Modern software can be ridiculously complicated, but most users don't care at all for complexity: they want information presented to them clearly, and they want to be able to navigate said information sensibly. By turning enormous select lists into hinting dropdowns, Chosen formats information sensibly and allows users to select what they want quickly. Ideal accessibility from a user's perspective.</p>

<h2>Bandit</h2>

<p>There's been a fair amount of <a href="http://www.chrisstucchio.com/blog/2012/bandit_algorithms_vs_ab.html">discussion</a> recently about the <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>, especially as it relates to A/B testing. I've done A/B testing with Rails before but never really enjoyed it; but I recently came across the <a href="https://github.com/bmuller/bandit">bandit</a> gem and I know I'll be using it extensively moving into the future.</p>

<p>Using multi-armed bandit solutions, you can test lots of options at once, and for as long as you like. Gradually the numbers for the test will reflect the reality of user preference: you don't need a set number of tests (as per A/B testing) and you aren't confined to only two options. Ultimately, you don't need to guess what a user wants. You can make some reasonable guesses and set them all up as possibilities, and over time, user choice will guide the direction of your site. And that's pretty awesome.</p>

<p>In the end, usability is about making your software more responsive and more presentable to your audience. Try out these libraries, but more than that, keep in mind the principles that guide them. By following those, you're guaranteed to make software that's much more usable than it would be otherwise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Routing with Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails/"/>
    <updated>2012-05-22T23:08:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails</id>
    <content type="html"><![CDATA[<p>I love Rails' routing system. Quickly and easily connecting English-readable URLs to complicated web actions is one of the joys of working in one of the coolest web frameworks on the Internet. At Synthetic, we're ramping up to get a new site out, and as part of the push for that I implemented some cool dynamic routing. I wanted to briefly summarize how and why I went with the routing choices I did, to illustrate using routes expressively and, hopefully, easily.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Hipstamatic has gear. Lots and lots of gear. We have over 100 lenses, flashes, and films; but from a programmatic perspective they're all really similar -- they all have a name, a description, some assets associated to them... And so they're all lumped together in a single model called <code>Gear</code>. Our new application is intended to let users browse our entire gear collection, and so obviously it has a single controller that (surprise surprise) allows you to see each piece of gear. Thus we wind up with routes like this:</p>

<p><code>
  gear/alfred
  gear/dreampop
  gear/stache
</code></p>

<p>And that's kind of tragic. Each type of gear should have its own route, even if they're all in the same model. Something like this would be both more readable and more expressive:</p>

<p><code>
  lenses/alfred
  flashes/dreampop
  films/stache
</code></p>

<p>Of course, having a controller for each kind of gear would be crazy. Happily, Rails provides some easy routing solutions!</p>

<h2>The Solution</h2>

<p>In our routes.rb, for each kind of resource that we're expecting, we create matching routes:</p>

<p><code>ruby
[:lenses, :films, :flashes, :cases].each do |gear|
  match "#{gear}/:id", :controller =&gt; :gear, :action =&gt; :show, :type =&gt; gear, :as =&gt; gear
end
</code></p>

<p>Let's dissect this routing statement in two steps. For the first, obviously, we're linking a route like <code>lenses/a1</code> or <code>flashes/cherry</code> to the gear controller. Importantly we're also passing a type: either lenses, films, flashes, or cases, instructing the controller which endpoint we want. In said controller, we should make sure that this passed type and the name of the piece of gear match. Otherwise people would go to <code>lenses/dreampop</code> or <code>flashes/alfred</code> and still see the correct resource despite specifying an invalid type and name combination. That would just be madness!</p>

<p>```ruby
class GearController &lt; ApplicationController
  before_filter :find_gear</p>

<p>  private</p>

<p>  def find_gear</p>

<pre><code>@gear = Gear.type(params[:type].to_s.singularize).where(:reference =&gt; params[:id]).first if params[:id]
</code></pre>

<p>  end
end
```</p>

<p>Type is a named scope that matches the passed params[:type] to a database column storing the actual type of gear. So this will try to find a lens or flash or what have you with the appropriate reference name. Simple enough.</p>

<p>For the second part of the above route, the <code>:as =&gt; gear</code> part creates named routes like lenses_path and films_url. With that in mind, it's easy for us to dynamically generate links based only on the gear object. This is the helper that allows us to do so:</p>

<p><code>ruby
def multi_path(obj)
  self.send("#{obj.type.pluralize.downcase}_path".to_sym, obj.reference)
end
</code></p>

<p>So I can use <code>multi_path(Gear.find_by_name('Kaimal Mark II'))</code> and the route will be generated as if I had typed <code>lenses_path</code> instead of <code>multi_path</code>: similarly with any object that responds to type and reference, which happily for me is all gear. This is important because I don't want to have to use a switch in iterated blocks to figure out which path name I want to use. Now I can just use multi_path and be guaranteed that the correct one will be selected.</p>

<p>With only a few lines of code, it's easy to make routes that were previously clunky and unexpressive into sensible, readable endpoints. And you don't have to sacrifice DRY to do so. If you have a lot of data that's expressed through only one controller, consider dynamic routing like this. It's easier for customers to remember URLs that are readable to them, and this is a good way to make that happen.</p>
]]></content>
  </entry>
  
</feed>
