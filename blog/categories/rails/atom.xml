<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-07-12T14:41:46-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Concerns III: Metatags]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/12/rails-concerns-iii-metatags/"/>
    <updated>2012-07-12T09:48:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/12/rails-concerns-iii-metatags</id>
    <content type="html"><![CDATA[<p>Following parts <a href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/">one</a> and <a href="http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable/">two</a> of my series on Rails concerns, I'm going to finish up with an extremely useful controller concern: automatically adding metatags to (and correctly displaying individualized titles on) your pages. Metatags, of course, are SEO-boosters that you should really be using if you aren't already. In addition to improving your search engine ranking, they allow your pages to appear idiomatically in Facebook's Open Graph. Of course, everyone wants metatags on each and every page on your site, but unfortunately it can be sort of a headache getting them there. Using the <a href="https://github.com/kpumuk/meta-tags/">meta-tags</a> gem and some good old-fashioned hard work, though, we can implement a very simple method to get metatags into every page of our application with minimal hassle.</p>

<!-- more -->


<h2>Setup</h2>

<p>Include the meta-tags gem in your Gemfile:</p>

<p><code>ruby
gem 'meta-tags', :require =&gt; 'meta_tags'
</code></p>

<p>While the gem itself hasn't been updated for awhile, that doesn't really matter; it still functions quite well for our purposes. Once it's in the Gemfile, we'll configure some sensible defaults in our application layout, <code>application.html.erb</code>.</p>

<p><code>ruby
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;%= display_meta_tags :site =&gt; 'Your Site Name Here', :keywords =&gt; Metatags::KEYWORDS %&gt;
  ...
&lt;/head&gt;
</code></p>

<p>We'll be defining that <code>CONSTANTS</code> constant shortly. This ensures that on each page the name of your site appears in the title, all by itself if you don't specify anything else, and that keywords appear in the keywords <code>meta</code> tag, which robots like the Googlebot use when computing your page's relevance.</p>

<h2>The Concern</h2>

<p>The meta-tags gem allows us to specify additional hashed options in either controllers or views: these options are concatenated with the defaults specified above to create attractive and meaningful metatags for each and every page. Since controllers tend to encapsulate models, I elected to make this a controller concern. (And forget doing this in views: replicating this code in each and every view is not my idea of a good time.) So our controller should, ideally, look somewhat like this:</p>

<p>```ruby
class UsersController &lt; ApplicationController
  before_filter :find_user</p>

<p>  include Metatags
  metatags :title => :name, :description => :summary, :short_tag => :slug, :keywords => :name, :canonical => :user_url</p>

<p>  private</p>

<p>  def find_user</p>

<pre><code>@user = User.find(params[:id]) if params[:id]
</code></pre>

<p>  end
```</p>

<p>We specify with a hash how the metatags should be constructed: the keys of the hash are the names of each metatag we intend to use, while the values are the methods that need to be executed on the controller's object in order to get the information for that tag. In other words, if we have an object called <code>@user</code>, then we want the title of the page to include <code>@user.name</code> -- and that's represent by a hash that looks like <code>:title =&gt; :name</code>. However, this won't work for every key and value. For example, the <code>:canonical</code> key should indicate how to find the canonical URL of this resource, so we'll need a special exception for that... and the Facebook Open Graph name for <code>:canonical</code> is <code>:url</code>, so we'll need to switch it when we generate the Facebook tags.</p>

<p>This, then, is the actual module itself:</p>

<p>```ruby
module Metatags
  extend ActiveSupport::Concern</p>

<p>  OG_TAGS = [:title, :type, :image, :url, :description]
  KEYWORDS = ['default', 'keywords', 'here']</p>

<p>  included do</p>

<pre><code>append_before_filter :set_metatags
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def metatags(hash)
  @hash = hash
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def set_metatags</p>

<pre><code>object = self.instance_variable_get("@#{self.class.to_s.underscore.split('_').first.singularize}")
hash = self.class.instance_variable_get(:@hash)

if object
  new_hash = {:open_graph =&gt; {}}
  hash.each do |tag, method|
    value = object.send(method) if object.respond_to?(method)

    if tag == :keywords
      value = Array(value) + KEYWORDS
    elsif tag == :canonical
      value = self.send(method, object)
    end

    new_hash[tag] = value
    tag = :url if tag == :canonical
    new_hash[:open_graph][tag] = value if OG_TAGS.include?(tag)
  end
  set_meta_tags new_hash
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Obviously this concern is somewhat complicated: bear with me and I'll explain it.</p>

<p>At the top of the code, we define which OpenGraph tags we care about, as well as the default keywords for our application. When the module is included, it appends a <code>before_filter</code> to its controller that will try to set all the metatag information. However, it also creates a new class method on its included class, a side-effect of having a child module called <code>ClassMethods</code>: in this case, it provides included controllers with a method called <code>metatags</code> that accepts a hash of metatag names and method names, as I discussed above.</p>

<p>Finally, we have a private method called <code>set_metatags</code> that performs the actual heavy lifting of the concern. It searches for an instance variable named after the controller itself: so if you have a <code>UsersController</code>, it tries to find an instance variable called <code>@user</code>. If that object exists, it tries to populate a new hash with the result of sending it each hash value.</p>

<p>We have two special exceptions we're concerned with. First, we don't want to replace the existing site keywords -- we only want to add to them. So if the tag is <code>:keywords</code> we add the keywords in <code>KEYWORDS</code> to whichever ones we passed to <code>meta_tags</code>. Second, if the tag is <code>:canonical</code>, we do something a little special. We assume the key is a Rails named route that will accept one argument, the controller's object, to generate a correct canonical URL.</p>

<p>Underneath that, we switch the name of the <code>:canonical</code> tag to <code>:url</code> so that the Facebook Open Graph tags are set up correctly. With that you're all done. Each controller will automatically try to query its object as you specified and set metatag information for each view based on the results of those queries.</p>

<h2>Caveats</h2>

<p>Because the metatag creation happens in a <code>before_filter</code>, the ordering of your filters becomes crucially important. If you have a <code>before_filter</code> that finds your controller's primary object like my controller sample above, it's vital that you place the <code>before_filter</code> above the concern's <code>include</code>, or, if you'd prefer, use <code>prepend_before_filter</code> instead of <code>before_filter</code>. Otherwise the metatag concern will place its <code>before_filter</code> ahead of the one that finds your object, your object will be nil when <code>set_metatags</code> runs, and the metatag information will never display correctly on the page.</p>

<p>Though complicated, I think this example best demonstrates the power and portability of concerns. With one simple method invocation in your controller, you generate an immense wealth of SEO and Open Graph information: and the best part is, you only had to write the code to do this once. Further customizability can easily be achieved with additions to the module to better fit your application's specific concerns.</p>

<p>This ends the first part of my series on Rails concerns. While I don't have anything else exciting to show off presently, the concern pattern is a powerful one that I've used a lot in the past and that I intend to use a lot in the future. Thus, when I come up with something else cool and interesting, I'll definitely continue talking about awesome Rails concerns.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns II: Taggable]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable/"/>
    <updated>2012-07-04T15:31:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable</id>
    <content type="html"><![CDATA[<p>For the second part of my series on Rails concerns (following <a href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/">part one earlier this week</a>), I'll be dissecting a tagging system and how to make it concerned. Of course, you have great gems like <a href="https://github.com/mbleigh/acts-as-taggable-on/">acts-as-taggable-on</a>, but if you want significant customized functionality in either your Tag class or the taggables, you're going to have to roll your own solution. That's what I'm doing for GirlsGuideTo, and this is how I implemented it.</p>

<!-- more -->


<h2>The Tag Model</h2>

<p>The tag model itself is fairly straightforward:</p>

<p>```ruby
class Tag &lt; ActiveRecord::Base
  has_many :taggings</p>

<p>  has_many :addresses, through: :taggings, source: :taggable, source_type: Address
  has_many :users, through: :taggings, source: :taggable, source_type: User
end
```</p>

<p>Unfortunately, you can't just say <code>belongs_to :taggable, through: :taggings</code>. Polymorphic has-and-belongs-to-many associations don't work, since they have no real table to select from. To illustrate this concept, consider the <code>Tag</code> model above: if you had a line like <code>belongs_to :taggable</code> and called <code>tag.taggables</code>, what would be returned? Theoretically an array of objects, but the objects would be of all different sorts: some would be addresses, some would be users. And how would they be grabbed from the database? You can't <code>SELECT * from taggables</code>, since there is no taggables table.</p>

<p>This is frustrating, but easy enough to work around. You'll have to specify every model that's taggable in the <code>Tag</code> class. But since we'll be employing a concern here, we know that all of the taggable classes will respond the same way. Thus, if you're confident, you can define a taggables method yourself:</p>

<p>```ruby
  def taggables</p>

<pre><code>[addresses + users].flatten
</code></pre>

<p>  end
```</p>

<p>Whether or not you decide to do this is up to you. I would recommend against it since likely you'll want to display the different kinds of taggables in different places anyway.</p>

<h2>The Join Model</h2>

<p>Tag has-and-belongs-to-many taggables through a join model. That model is <code>Tagging</code>, and should look like this:</p>

<p>```ruby
class Tagging &lt; ActiveRecord::Base
  attr_accessible :tag_id, :taggable_id, :taggable_type</p>

<p>  belongs_to :tag
  belongs_to :taggable, :polymorphic => true
end
```ruby</p>

<p>There's nothing particularly surprising here. Just remember to set the <code>taggable</code> to polymorphic or Rails won't fill in the association correctly.</p>

<h2>The Taggable Concern</h2>

<p>Finally, we can get to the concern itself. This is how I've set it up:</p>

<p>```ruby
module Taggable
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>has_many :taggings, :as =&gt; :taggable
has_many :tags, :through =&gt; :taggings
</code></pre>

<p>  end</p>

<p>  def tag(name)</p>

<pre><code>name.strip!
tag = Tag.find_or_create_by_name(name)
self.taggings.find_or_create_by_tag_id(tag.id)
</code></pre>

<p>  end</p>

<p>  def tag_names</p>

<pre><code>tags.collect(&amp;:name)
</code></pre>

<p>  end
end
```</p>

<p>This uses a new feature of concerns: the <code>included</code> statement. Anything inside this block will be executed by the including class when the inclusion occurs. In this case, we'll be including this concern in multiple ActiveRecord models -- and those models will automatically <code>has_many</code> :taggings and :tags.</p>

<p>And on those models we'll be able to do some neat stuff. We can automatically add a tag just by calling <code>model.tag("tag_name")</code>: if it didn't exist before, it will automatically be created, and then it'll be added to the model's taggings. Also we can get a handy array of all the names of tags for a model. This is just the start of the functionality you can employ, though. Taggable would be a sensible place to put tag cloud creation and tagging contexts, if you wanted to ape more functionality from acts-as-taggable-on while still retaining your own customized implementations.</p>

<p>Next time I discuss concerns, I'll talk about an ActionController concern to improve your page's SEO and Facebook Graph integration. It'll be pretty awesome, so stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns I: Starting with Redcarpet]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/"/>
    <updated>2012-07-01T20:32:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet</id>
    <content type="html"><![CDATA[<p>Rails concerns are a fancy way of saying Ruby modules. 37signals uses concerns <a href="http://37signals.com/svn/posts/3167-code-spelunking-in-the-all-new-basecamp">a lot in the new Basecamp</a>, and it's easy to see why: separation and recatoring allow you to reuse code more sensibly and test it in only one place. But concerns aren't only for code refuse -- by allowing you to unclutter models, they make it more obvious where code in your application lives. Even though, for example, orders are the only model in your system being shipped, having a concern called Shipping makes it completely obvious that that's where all the functionality for shipping lies... whereas a newcomer to your application would have to search through the order model to find it.</p>

<p>I've been using concerns extensively in GirlsGuideTo's upcoming application, and I figured it'd be an interesting read if I shared the ones I've made so far. They're not too complicated (this first one I'm posting mostly just to illustrate the concept), but but don't let that fool you. They can be super complicated and really involved -- but more than that, concerns just make your code better, so you should definitely be using them!</p>

<!-- more -->


<h2>Redcarpeted</h2>

<p>A lot of fields in GirlsGuideTo are Markdown encoded by the pretty awesome <a href="https://github.com/tanoku/redcarpet/">Redcarpet</a> gem. These fields occur across models, and rather than copy and paste code all over the place, I extracted the idea of converting fields to and from Markdown into a concern.</p>

<p>```ruby
module Redcarpeted
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def redcarpet(field)
  define_method("#{field}_markdown".to_sym) do
    read_attribute(field)
  end

  define_method("#{field}_html".to_sym) do
    Redcarpet.new(read_attribute(field)).to_html
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ActiveSupport::Concern</code> is the magic that makes concerns so ... magical. Simply by including another module called <code>ClassMethods</code>, <code>ActiveSupport::Concern</code>automatically knows to extend the base class with those methods when it's included.</p>

<p>In this case, this allows you to do something like this in your model:</p>

<p>```ruby
  class Post &lt; ActiveRecord::Base</p>

<pre><code>include Redcarpeted

redcarpet :body
</code></pre>

<p>  end
```</p>

<p>Now your Post has two new methods: <code>body_markdown</code> and <code>body_html</code>, allowing you to quickly and easily access the raw Markdown and formatted HTML for any attribute in your model. (And if you're curious, the reason to bother including a <code>body_markdown</code> method is in case you decide to override the base method <code>body</code> yourself at some future point.)</p>

<p>That's just the starts of Rails concerns, though. Next time I'll post a more complicated example with greater ActiveRecord connectivity that will hopefully be a lot more exciting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/"/>
    <updated>2012-06-28T15:09:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages</id>
    <content type="html"><![CDATA[<p>One of the coolest features of Rails 3.2 is <a href="http://api.rubyonrails.org/classes/ActiveSupport/TaggedLogging.html">tagged logging</a>. Using the UUID tagged logger, you can give each individual request a UUID reference number in order to track individual errors, find them, and smoosh them. It's generally pretty awesome.</p>

<p>But it'd be even awesomer if actual errors in your application referenced this UUID, wouldn't it? Maybe even emailed it to you in exception_notification? Presented it to your users so they could say directly, "I encountered error 123xyz," rather than force you to look through a huge amount of backlog to find their specific exception?</p>

<p>Happily, you can do just this!</p>

<!-- more -->


<h2>Rescue_from Madness</h2>

<p>Doing so requires abusing rescue_from a little bit, though. Set up something like this in your application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from ActionController::UnknownAction, with: :render_404
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>This will prevent any error from rendering the default Rails error pages. Instead we'll set up our own error pages like so:</p>

<p>```ruby
  def render_500(exception)</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message
Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
Rails.logger.fatal exception.backtrace.join("\n")
render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>And finally, in your view, actually include the request's unique identifier:</p>

<p><code>ruby
  &lt;h1&gt;&lt;%= @message.split(/\s/).collect(&amp;:capitalize).join(' ') %&gt; &lt;small&gt;&lt;%= @status %&gt;&lt;/small&gt;&lt;/h1&gt;
  &lt;h3&gt;Error Code: &lt;%= request.env['action_dispatch.request_id'] %&gt; &lt;/h3&gt;
</code></p>

<p>Dynamic error pages like what I'm suggesting are powerful but also dangerous. Static error pages are simpler and more maintainable: if the code executing your error page has an error in it, then your server process will loop until finally throwing a system stack exception. But if you keep your dynamic error pages simple and well-tested, it's pretty unlikely that'll happen. Just be careful when using this system -- maybe even don't render the exception in your usual layout, but render it in an error-specific one -- to reduce the chance of your error pages also erroring, and you'll be golden.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing Sites for Users]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users/"/>
    <updated>2012-06-17T17:52:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users</id>
    <content type="html"><![CDATA[<p>Designing a new site from scratch can be difficult -- not technically, but from a usability perspective. What color will your users like best? How big should your buttons be? Where should advertising be placed? Of course, there are <a href="http://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758">amazing usability books</a> out there, but there are some questions you can only answer through experience. Of course, designing for usability should be one of our top priorities -- and here are three cute little libraries that will help you make your sites awesome, beautiful, and most importantly, usable for your users.</p>

<!-- more -->


<h2>Mailcheck</h2>

<p>The amazing <a href="https://github.com/Kicksend/mailcheck">Mailcheck</a> library is great for any site that accepts email addresses. According to its creators, <a href="http://kicksend.com">Kicksend</a>, <a href="http://blog.kicksend.com/how-we-decreased-sign-up-confirmation-email-bounces-by-50/">Mailcheck reduced email confirmation signup bounces by 50%</a>. Now that's pretty impressive.</p>

<p>I also love Mailcheck's philosophy. The guiding idea here -- that users will make errors, and software should respond efficiently to correct them -- is true no matter what you're making, from an iPhone app to a website. Always remember that users will improperly use your software. Guiding them back to the appropriate path is your responsibility, with libraries like Mailcheck specifically, but also generally through your app's flow and and user experience. Every form field that encounters frequent errors should have a Mailcheck-like check around it; your users will thank you by loving your app even more.</p>

<h2>Chosen</h2>

<p><a href="https://github.com/harvesthq/chosen">Chosen</a> is cute little syntactical sugar that turns select boxes from ugly, long monstrosities into helpful little widgets. Check out the <a href="https://github.com/harvesthq/chosen">sample page</a> to see everything that it can do; if you have a select box on your site (and chances are that you do), then you should be using Chosen to help users select items from it more effectively.</p>

<p>Chosen expresses another important usability concept -- accessibility. Modern software can be ridiculously complicated, but most users don't care at all for complexity: they want information presented to them clearly, and they want to be able to navigate said information sensibly. By turning enormous select lists into hinting dropdowns, Chosen formats information sensibly and allows users to select what they want quickly. Ideal accessibility from a user's perspective.</p>

<h2>Bandit</h2>

<p>There's been a fair amount of <a href="http://www.chrisstucchio.com/blog/2012/bandit_algorithms_vs_ab.html">discussion</a> recently about the <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>, especially as it relates to A/B testing. I've done A/B testing with Rails before but never really enjoyed it; but I recently came across the <a href="https://github.com/bmuller/bandit">bandit</a> gem and I know I'll be using it extensively moving into the future.</p>

<p>Using multi-armed bandit solutions, you can test lots of options at once, and for as long as you like. Gradually the numbers for the test will reflect the reality of user preference: you don't need a set number of tests (as per A/B testing) and you aren't confined to only two options. Ultimately, you don't need to guess what a user wants. You can make some reasonable guesses and set them all up as possibilities, and over time, user choice will guide the direction of your site. And that's pretty awesome.</p>

<p>In the end, usability is about making your software more responsive and more presentable to your audience. Try out these libraries, but more than that, keep in mind the principles that guide them. By following those, you're guaranteed to make software that's much more usable than it would be otherwise.</p>
]]></content>
  </entry>
  
</feed>
