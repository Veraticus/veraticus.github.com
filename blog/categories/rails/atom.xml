<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-10-22T14:55:13-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Concerns IV: Class Methodable]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable/"/>
    <updated>2012-10-22T14:27:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable</id>
    <content type="html"><![CDATA[<p>In my application, seed data is an unfortunate necessity. I don't like it but it's there, and it's tightly integrated into many parts of the app (dropdowns, navigational links, and so on). Finding that seed data also tends to be rather ugly and long, unfortunately. Who wants to type <code>Tag.find_by_name('Health &amp; Wellness')</code> or one of the finder variations every time you're looking for something? Not me, that's for sure. I found myself aliasing these finders constantly as class methods: so, the above would be much more easily referenced as <code>Tag.health_wellness</code>.</p>

<p>Once I started duplicating this functionality across models I knew I had a concern. This is the module I came up with to encapsulate it.</p>

<!-- more -->


<h2>Methodizing Names</h2>

<p>The first problem with a concern like this is that it's no easier to call class methods that have weird characters in them. You can do <code>Tag.send('Health &amp; Wellness')</code> but the goal here is to eliminate intervening calls, so that we end up with <code>Tag.health_wellness</code>. Having <code>send</code> in there looks weird and doesn't seem very clean.</p>

<p>I opted to fix this with a new String method I called <code>methodize</code>. Put it in your lib folder and Rails will load it when the application starts.</p>

<p>```ruby
class String
  def methodize</p>

<pre><code>self.gsub(/\s/, '').downcase.gsub(/[^a-z0-9]/, '_')
</code></pre>

<p>  end
end
```</p>

<h2>Setting a Scope</h2>

<p>The models that employ this concern will probably have different columns you'll want to find them by. One might be called 'name', whereas another might be 'title' or 'slug'. To get around these differences, our concern will assume that each model will have a scope that smooths over these differences. I called that scope 'named'.</p>

<p><code>ruby
class Tag
  scope :named, lambda {|n| where(name: n.downcase)}
end
</code></p>

<h2>Creating the Concern</h2>

<p>The concern itself is quite simple. It consists of one method, <code>class_methodable</code>. We call that with an array of names that we want to turn into class methods. For each of those, we define a singleton method that sets or gets a class variable of the value we're looking for. The code itself follows:</p>

<p>```ruby
module ClassMethodable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def class_methodable(methods)

  methods.each do |method|
    define_singleton_method(method.to_s.methodize) do
      v = "@@#{method.to_s.methodize}"

      if class_variable_defined?(v)
        class_variable_get(v)
      else
        class_variable_set(v, self.named(method.to_s).first)
      end
    end
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Using It</h2>

<p>Now that everything's in place, actually using the concern is quite simple. In our class:</p>

<p>```ruby
class Tag
  include ClassMethodable</p>

<p>  class_methodable 'Health &amp; Wellness', 'Relationships', 'Other Stuff'
end
```</p>

<p>And in our code:</p>

<p><code>ruby
Tag.relationships # =&gt; Tag.named('Relationships')
Tag.health_wellness # =&gt; Tag.named('Health &amp; Wellness')
Tag.other_stuff # =&gt; Tag.named('Other Stuff')
</code></p>

<p>Now we can reference our seed data quickly and cleanly, without having to resort constantly to finders.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unobtrusive JavaScript Facebook-Style More Button]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button/"/>
    <updated>2012-10-14T21:20:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button</id>
    <content type="html"><![CDATA[<p>I spent awhile yesterday Googling for a Facebook-style more button with a graceful fallback: something where, if the user didn't have JavaScript, they'd still see something sensible... but if they did, they'd get a sweet fade-in of more content appended right to the content container. Oh, and I also didn't want to write separate views for JSON returns, so it had to deal with HTML returns and strip out the unnecessary bits.</p>

<p>I didn't find anything, so I took a crack at creating it myself. This is the result.</p>

<!-- more -->


<h2>How to Use It</h2>

<p>Before coding I sat down and tried to figure out how this beast would work.</p>

<p>Because it was unobtrusive, it should work on standard links, replacing them with an AJAX-y alternative if they have appropriate attributes. I hit on a link that looked like this:</p>

<p>```ruby
&lt;%= link_to 'More...'.html_safe, root_path(page: @page + 1),</p>

<pre><code>class: 'next_page', 'data-selector' =&gt; '.articles .article',
'data-container' =&gt; '.articles'%&gt;
</code></pre>

<p>```</p>

<p>If the link has <code>data-selector</code> and <code>data-container</code> attributes, it's supposed to be an AJAX more button. The selector tells the script what to look for in the new page; the container tells it where to append the newly found elements. With this use case in hand, I proceeded to coding.</p>

<h2>The Code</h2>

<p>I apologize in advance if there's a cleaner way to do this. My CoffeeScript is pretty weak.</p>

<p>```coffeescript
$(document).ready ->
  $('[data-selector]').click (event) -></p>

<pre><code>element = $(this)
url = element.attr 'href'
return false unless url
container = $(element.attr 'data-container')
selector = element.attr 'data-selector'
more = true

$.ajax
  url: url
  success: (data) -&gt;
    elements = $($(data).find(selector))
    if elements.length == 0
      element.html('All content loaded')
             .addClass('done')
             .removeAttr('href')
    else
      container.append elements
      elements.css opacity: 0
      elements.imagesLoaded (event) -&gt;
        elements.animate opacity: 1
        element.attr('href', $(data).find('[data-selector]').attr('href')).
                html('More &amp;raquo;')
        container.masonry 'appended', elements, true if element.attr('data-masonry')

  beforeSend: -&gt;
    element.html('Loading more...')
           .addClass('loading')

return false
</code></pre>

<p>```</p>

<p>This should be pretty straightforward: we find the URL of the next page from the href of the link itself, and also the container we're adding elements to and the selector. We make an AJAX request for the new page and parse it for the selector, appending each result to the container and fading them in once all the images have loaded. Afterwards, we update the URL to request the next new page of content if someone clicks on the "More" button again -- or we disable the "More" button if we found no content.</p>

<p>Overall pretty simple but I was satisfied with this solution. Oh, and there's a line there for integration into the really excellent <a href="http://masonry.desandro.com/">jQuery Masonry</a> script, if you include a data-masonry attribute on your link element.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seamless POST Logins with Rack Middleware]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/10/seamless-post-logins-with-rack-middleware/"/>
    <updated>2012-10-10T18:47:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/10/seamless-post-logins-with-rack-middleware</id>
    <content type="html"><![CDATA[<p>It's not uncommon to have login-required forms accessible to users who aren't logged in -- for example, maybe you're trying to encourage someone to start writing some content without having to bother logging in first. Of course, they have to log in before they can post, but what happens when they push that big "post" button? Or take another example: you have a button to thumbs-up some content. Only logged-in users should be able to thumbs-up any content, but you always want to display the button. But then what happens when someone who's not logged in presses the button? In most Rails applications, they'd be logged in, redirected back to the page they were referred from, and they'd have to click the thumbs-up again.</p>

<p>That sort of sucks. They already clicked it once. Why can't we remember that?</p>

<p>I ran into this problem myself today in the context of the thumbs-up button. After doing some research and realizing there was no great Rails 3 solution to the problem, I decided I would roll one myself. The result is some complicated but awesome Rack middleware that I think would be pretty handy for most Rails developers.</p>

<!-- more -->


<h2>Pre-Controller Setup</h2>

<p>This method is rather login-agnostic; it should work if you're using <a href="https://github.com/plataformatec/devise">Devise</a>, <a href="https://github.com/intridea/omniauth">OmniAuth</a>, <a href="https://github.com/plataformatec/devise/wiki/OmniAuth:-Overview">both</a>, or neither. For the purposes of my examples, however, I'm using OmniAuth.</p>

<p>First, put some code wherever you redirect to force login. I do that when I see a <code>CanCan::AccessDenied</code> error, but you should do it wherever makes sense for you. Here's an example method very similar to the one I use.</p>

<p>```ruby
class ApplicationController</p>

<p>  private</p>

<p>  def redirect_to_login</p>

<pre><code>redirect_to login_path(return_to: request.path, return_post_params: params, return_method: request.method)
</code></pre>

<p>  end
end
```</p>

<p><code>login_path</code> should redirect somewhere sensible: I chose sessions#new. Once there, we reset the session (to prevent any funny business) and then assign a bunch of attractive new session variables.</p>

<p>```ruby
class SessionsController &lt; ApplicationController
  def new</p>

<pre><code>reset_session
session[:return_to], session[:return_post_params], session[:return_method] = params[:return_to], params[:return_post_params], params[:return_method]

redirect_to "/auth/facebook"
</code></pre>

<p>  end
end
```</p>

<p>Since I'm using OmniAuth and Facebook, this will result in the user being logged in. In the login callback -- I chose sessions#create -- we need to do some special detection and redirection.</p>

<p>```ruby
class SessionsController &lt; ApplicationController
  def create</p>

<pre><code>user = User.create(request.env)

if user
  session[:user_id] = user.id
  flash[:success] = "Hi &lt;b&gt;#{user.name}&lt;/b&gt;, you are now logged in."

  if session[:return_method] != 'GET'
    redirect_to '/redirect_back'
  else
    redirect_to session[:return_to] || '/'
  end
else
  redirect_to root_url, flash: {error: 'You could not be logged in.'}
end
</code></pre>

<p>  end
end
```</p>

<p>The interesting portion is <code>redirect_to '/redirect_back'</code>. That's our middleware hook: when the session variables are set correctly, and you go to <code>/redirect_back</code>, the middleware will activate and do a POST to the application. So, in essence, <code>/redirect_back</code> stands in for whatever request you just tried to go. That's why this doesn't work with GET requests: with a GET, the new URL for the page will be <code>/redirect_back</code> regardless of what the page is, which looks pretty weird.</p>

<h2>The Middleware</h2>

<p>```ruby
class RedirectBack</p>

<p>  def initialize(app)</p>

<pre><code>@app = app
</code></pre>

<p>  end</p>

<p>  def call(env)</p>

<pre><code>req = Rack::Request.new(env)

if req.path == '/redirect_back' &amp;&amp; req.session[:return_method] &amp;&amp; req.session[:return_post_params] &amp;&amp;
  req.session[:return_to] &amp;&amp; req.session[:user_id]

  env['CONTENT_TYPE'] = 'application/x-www-form-urlencoded'

  env['REQUEST_METHOD'] = req.session.delete(:return_method)
  env["rack.input"] = StringIO.new(Rack::Utils.build_nested_query(req.session[:return_post_params]))
  req.session.delete(:return_post_params).each do |param, val|
    req.params[param] = val
  end

  new_url = req.session.delete(:return_to)
  ['REQUEST_PATH', 'REQUEST_URI', 'PATH_INFO'].each do |req|
    env[req] = new_url
  end

  req.session[:redirected] = true
end

@app.call(env)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The whole idea of this middleware is to reformat the path and add in all the appropriate params from the session variables, and then call the Rails application with it. Rails believes that -- despite the URL being <code>redirect_back</code> -- we've made a correctly-formatted post and processes it correctly, sending another redirect to the client when it's completed.</p>

<h2>Post-Controller Setup</h2>

<p>The only problem is that, since we're dealing with forms here, Rails needs a CSRF token. Without it, it'll purge the session at the beginning of the request and we'll end up in a redirect loop.</p>

<p>However, remember how we <code>reset_session</code> at sessions#new? We can be confident that this session is not fixated; we cleaned it before entering the middleware, and the middleware only deals with session variables. Provided you don't use the cookie session storage mechanism (and you should not be), you can be sure enough of the user's identity to ignore the authenticity token on this one request.</p>

<p>We also need to ensure that Rails places a new, correct CSRF token into the session. Otherwise users' sessions will be deleted by the CSRF handlers upon their next post, which will seem to have an invalid, old token.</p>

<p>```ruby
class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  skip_before_filter :verify_authenticity_token, :if => :redirected?</p>

<p>  def redirected?</p>

<pre><code>if session[:redirected]
  flash.keep
  session[:return_to], session[:return_post_params], session[:return_method], session[:redirected] = nil
  self.form_authenticity_token
  return true
end
</code></pre>

<p>  end
end
```</p>

<p>As a bonus we also clean out the session a little bit so that <code>/redirect_back</code> won't work again.</p>

<p>And that's that! Now a user can initiate a POST and be automatically logged in, see the POST completed, and be redirected to the output -- all with just one little button press. Though the Rails 2 method of doing this was substantially easier, I think this middleware method has an elegance to it. And the usability certainly can't be beat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages, Corrected]]></title>
    <link href="http://joshsymonds.com/blog/2012/08/13/dynamic-error-pages-corrected/"/>
    <updated>2012-08-13T14:32:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/08/13/dynamic-error-pages-corrected</id>
    <content type="html"><![CDATA[<p>Earlier today <a href="http://twitter.com/alain_meier">@alan_meier</a> pointed out that in certain circumstances, my post on <a href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/">dynamic error pages</a> leads to unexpected results: namely, though most errors are caught, 404s are not. I didn't experience this myself because most 404s, for me, result in an ActiveRecord::RecordNotFound error, since my application has a wildcard route at the very end. But if you don't then my post on dynamic error pages won't work for you very well. Here, then, is an explanation of the problem and how to fix it.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Summarized elegantly <a href="https://github.com/rails/rails/issues/671">here</a>:</p>

<blockquote><p>In Rails 2.3.x, one is able to stick this in ApplicationController to present the user with a custom 404 screen:</p>

<p><code>rescue_from(ActionController::RoutingError) { render :text =&gt; 'This is a custom 404.' }</code></p>

<p>Now in Rails 3, because routing is done as middleware (ActionDispatch), it seems that the ActionController::RoutingError that gets thrown by ActionDispatch no longer can be caught from ApplicationController -- the error is already thrown and ActionDispatch renders /templates/rescues/routing_error.erb before the controller can rescue_from the error.</p></blockquote>

<p>Essentially, <code>rescue_from ActionController::RoutingError</code> is never rescued because it's raised in Rack, not the application itself.</p>

<h2>The Solution</h2>

<p>Requires a couple changes on our parts. First, let's change our application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from AbstractController::ActionNotFound, with: :render_404 # To prevent Rails 3.2.8 deprecation warnings
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>So far, just as usual. Now we define the actual actions:</p>

<p>```ruby
  def render_500</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception = nil)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message

if exception
  Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
  Rails.logger.fatal exception.backtrace.join("\n")
else
  Rails.logger.fatal "No route matches [#{env['REQUEST_METHOD']}] #{env['PATH_INFO'].inspect}"
end

render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>Since we're going to be exposing <code>render_404</code> as an action, now, we have to make parameters into it optional: but we know that if <code>render_exception</code> doesn't receive an exception, it actually got a 404.</p>

<p>Finally, we need to add a globbed, wildcard route at the conclusion of our routes.rb. But if we just add one in, then engines and Gems that also rely on wildcard routes will fail. The solution is to do this through our application.rb, like so:</p>

<p>```ruby
module MyApplication
  class Application &lt; Rails::Application</p>

<p>  ...</p>

<p>  # 404 catcher
  config.after_initialize do |app|</p>

<pre><code>app.routes.append{ match '*a', :to =&gt; 'application#render_404' } unless config.consider_all_requests_local
</code></pre>

<p>  end
end
```</p>

<p>Now it won't punch any Gem or engine routes, but will still redirect 404s correctly to our render_404 action.</p>

<p>Thanks to <a href="http://twitter.com/alain_meier">@alan_meier</a> for bringing this problem to my attention, and I hope this correction helps some people out!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns III: Metatags]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/12/rails-concerns-iii-metatags/"/>
    <updated>2012-07-12T09:48:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/12/rails-concerns-iii-metatags</id>
    <content type="html"><![CDATA[<p>Following parts <a href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/">one</a> and <a href="http://joshsymonds.com/blog/2012/07/04/rails-concerns-ii-taggable/">two</a> of my series on Rails concerns, I'm going to finish up with an extremely useful controller concern: automatically adding metatags to (and correctly displaying individualized titles on) your pages. Metatags, of course, are SEO-boosters that you should really be using if you aren't already. In addition to improving your search engine ranking, they allow your pages to appear idiomatically in Facebook's Open Graph. Of course, everyone wants metatags on each and every page on your site, but unfortunately it can be sort of a headache getting them there. Using the <a href="https://github.com/kpumuk/meta-tags/">meta-tags</a> gem and some good old-fashioned hard work, though, we can implement a very simple method to get metatags into every page of our application with minimal hassle.</p>

<!-- more -->


<h2>Setup</h2>

<p>Include the meta-tags gem in your Gemfile:</p>

<p><code>ruby
gem 'meta-tags', :require =&gt; 'meta_tags'
</code></p>

<p>While the gem itself hasn't been updated for awhile, that doesn't really matter; it still functions quite well for our purposes. Once it's in the Gemfile, we'll configure some sensible defaults in our application layout, <code>application.html.erb</code>.</p>

<p><code>ruby
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;%= display_meta_tags :site =&gt; 'Your Site Name Here', :keywords =&gt; Metatags::KEYWORDS %&gt;
  ...
&lt;/head&gt;
</code></p>

<p>We'll be defining that <code>CONSTANTS</code> constant shortly. This ensures that on each page the name of your site appears in the title, all by itself if you don't specify anything else, and that keywords appear in the keywords <code>meta</code> tag, which robots like the Googlebot use when computing your page's relevance.</p>

<h2>The Concern</h2>

<p>The meta-tags gem allows us to specify additional hashed options in either controllers or views: these options are concatenated with the defaults specified above to create attractive and meaningful metatags for each and every page. Since controllers tend to encapsulate models, I elected to make this a controller concern. (And forget doing this in views: replicating this code in each and every view is not my idea of a good time.) So our controller should, ideally, look somewhat like this:</p>

<p>```ruby
class UsersController &lt; ApplicationController
  before_filter :find_user</p>

<p>  include Metatags
  metatags :title => :name, :description => :summary, :short_tag => :slug, :keywords => :name, :canonical => :user_url</p>

<p>  private</p>

<p>  def find_user</p>

<pre><code>@user = User.find(params[:id]) if params[:id]
</code></pre>

<p>  end
```</p>

<p>We specify with a hash how the metatags should be constructed: the keys of the hash are the names of each metatag we intend to use, while the values are the methods that need to be executed on the controller's object in order to get the information for that tag. In other words, if we have an object called <code>@user</code>, then we want the title of the page to include <code>@user.name</code> -- and that's represented by a hash that looks like <code>:title =&gt; :name</code>. However, this won't work for every key and value. For example, the <code>:canonical</code> key should indicate how to find the canonical URL of this resource, so we'll need a special exception for that... and the Facebook Open Graph name for <code>:canonical</code> is <code>:url</code>, so we'll need to switch it when we generate the Facebook tags.</p>

<p>This, then, is the actual module itself:</p>

<p>```ruby
module Metatags
  extend ActiveSupport::Concern</p>

<p>  OG_TAGS = [:title, :type, :image, :url, :description]
  KEYWORDS = ['default', 'keywords', 'here']</p>

<p>  included do</p>

<pre><code>append_before_filter :set_metatags
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def metatags(hash)
  @hash = hash
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def set_metatags</p>

<pre><code>object = self.instance_variable_get("@#{self.class.to_s.underscore.split('_').first.singularize}")
hash = self.class.instance_variable_get(:@hash)

if object
  new_hash = {:open_graph =&gt; {}}
  hash.each do |tag, method|
    value = object.send(method) if object.respond_to?(method)

    if tag == :keywords
      value = Array(value) + KEYWORDS
    elsif tag == :canonical
      value = self.send(method, object)
    end

    new_hash[tag] = value
    tag = :url if tag == :canonical
    new_hash[:open_graph][tag] = value if OG_TAGS.include?(tag)
  end
  set_meta_tags new_hash
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Obviously this concern is somewhat complicated: bear with me and I'll explain it.</p>

<p>At the top of the code, we define which OpenGraph tags we care about, as well as the default keywords for our application. When the module is included, it appends a <code>before_filter</code> to its controller that will try to set all the metatag information. However, it also creates a new class method on its included class, a side-effect of having a child module called <code>ClassMethods</code>: in this case, it provides included controllers with a method called <code>metatags</code> that accepts a hash of metatag names and method names, as I discussed above.</p>

<p>Finally, we have a private method called <code>set_metatags</code> that performs the actual heavy lifting of the concern. It searches for an instance variable named after the controller itself: so if you have a <code>UsersController</code>, it tries to find an instance variable called <code>@user</code>. If that object exists, it tries to populate a new hash with the result of sending it each hash value.</p>

<p>We have two special exceptions we're concerned with. First, we don't want to replace the existing site keywords -- we only want to add to them. So if the tag is <code>:keywords</code> we add the keywords in <code>KEYWORDS</code> to whichever ones we passed to <code>meta_tags</code>. Second, if the tag is <code>:canonical</code>, we do something a little special. We assume the key is a Rails named route that will accept one argument, the controller's object, to generate a correct canonical URL.</p>

<p>Underneath that, we switch the name of the <code>:canonical</code> tag to <code>:url</code> so that the Facebook Open Graph tags are set up correctly. With that you're all done. Each controller will automatically try to query its object as you specified and set metatag information for each view based on the results of those queries.</p>

<h2>Caveats</h2>

<p>Because the metatag creation happens in a <code>before_filter</code>, the ordering of your filters becomes crucially important. If you have a <code>before_filter</code> that finds your controller's primary object like my controller sample above, it's vital that you place the <code>before_filter</code> above the concern's <code>include</code>, or, if you'd prefer, use <code>prepend_before_filter</code> instead of <code>before_filter</code>. Otherwise the metatag concern will place its <code>before_filter</code> ahead of the one that finds your object, your object will be nil when <code>set_metatags</code> runs, and the metatag information will never display correctly on the page.</p>

<p>Though complicated, I think this example best demonstrates the power and portability of concerns. With one simple method invocation in your controller, you generate an immense wealth of SEO and Open Graph information: and the best part is, you only had to write the code to do this once. Further customizability can easily be achieved with additions to the module to better fit your application's specific concerns.</p>

<p>This ends the first part of my series on Rails concerns. While I don't have anything else exciting to show off presently, the concern pattern is a powerful one that I've used a lot in the past and that I intend to use a lot in the future. Thus, when I come up with something else cool and interesting, I'll definitely continue talking about awesome Rails concerns.</p>
]]></content>
  </entry>
  
</feed>
