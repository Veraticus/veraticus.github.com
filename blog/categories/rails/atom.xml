<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2013-02-04T18:06:39-06:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Chef Cookbooks for Rails]]></title>
    <link href="http://joshsymonds.com/blog/2013/01/22/chef-cookbooks-for-rails/"/>
    <updated>2013-01-22T12:36:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2013/01/22/chef-cookbooks-for-rails</id>
    <content type="html"><![CDATA[<p>I spent awhile trying to find other people's Chef cookbook collections for deploying Rails applications. In the absence of anything other than old GitHub repositories, I decided to write a quick post summarizing the cookbooks I used and a few settings that made them work as I expected. I'll go by the roles that I created to organize the cookbooks, starting with the most basic: base.</p>

<!-- more -->


<h2>base</h2>

<p><code>ruby
run_list %W(
  recipe[chef-client::delete_validation]
  recipe[chef-client::config]
  recipe[chef-client::service]
  recipe[apt]
  recipe[monit]
  recipe[postfix]
  recipe[openssh]
  recipe[ntp]
  recipe[vim]
  recipe[build-essential]
  recipe[user::data_bag]
  recipe[logrotate]
  recipe[ohai]
  recipe[ruby_build]
  recipe[rbenv::system]
  recipe[sudo]
  recipe[zsh]
  recipe[oh-my-zsh]
  recipe[collectd]
  recipe[collectd::attribute_driven]
  recipe[htop]
  recipe[runit]
  recipe[rsyslog::client]
)
</code></p>

<p>This is the run list I'm using as the base for all the servers. I don't think there's anything surprising here, but I do want to point out a few things:</p>

<ul>
<li><strong>openssh</strong> should be configured like this:</li>
</ul>


<p>```ruby
  default_attributes 'openssh' => {</p>

<pre><code>  'permit_root_login' =&gt; 'no',
  'password_authentication' =&gt; 'no'
}
</code></pre>

<p>```</p>

<p>You don't want to allow root logins or password logins. It is also probably worthwhile to delete any preexisting sudoer for your AMI image if one exists (like ubuntu for example), using...</p>

<ul>
<li><p><strong>user::data_bag</strong> from <a href="http://github.com/fnichol/chef-user">this cookbook</a>. It allows you to have data bags for your users that get automatically added (or removed) from every server. It's really helpful.</p></li>
<li><p>I went back and forth on <strong>ruby_build and rbenv</strong> in the base cookbook. Compiling your own Ruby takes significantly longer than installing Ruby from a package, and I could just compile Ruby on the application servers and use the Ruby package on everything else. Ultimately I decided to keep compiled Ruby in the base list -- it seems slightly faster than the package and allows me to apply performance patches, and since I made an AMI of the base role the speed difference didn't matter a whole lot to me. But I can definitely see taking this out.</p></li>
<li><p><strong>zsh and oh-my-zsh</strong> are obviously just silly nice-to-haves. Use a zsh theme that says the server name or else you'll get confused.</p></li>
</ul>


<h2>statistics</h2>

<p>I'm running Graylog2 and Graphite to compile logs and interesting statistics from our servers. This is the runlist that establishes the role dedicated to these two pieces of software, which I called <code>statistics</code>:</p>

<p><code>ruby
run_list %W(
  recipe[ebs]
  recipe[apache2]
  recipe[statsd]
  recipe[python]
  recipe[graphite]
  recipe[graylog2]
  recipe[graylog2::apache2]
)
</code></p>

<p>I use <a href="https://github.com/titanous/chef-ebs">this EBS cookbook</a> with this configuration:</p>

<p>```ruby
default_attributes 'ebs' => {</p>

<pre><code>'volumes' =&gt; {
  '/data' =&gt; {
    'size' =&gt; 100,
    'fstype' =&gt; 'xfs'
  }
}
</code></pre>

<p>  }
```</p>

<p>This server saves and compiles enormous amounts of data, and in order to hold it all correctly I provision an external EBS drive to contain it. I'm actually not even sure 100 gigs is enough space but it seems good for now. elasticsearch, mongodb, and graphite are all set up to save their data to subdirectores in /data. While I could easily have made this a RAID array instead, persistence of this data is not super important to me right now: while it would suck to lose all our analytics information, given our traffic it would rebuild into something useful very quickly anyway.</p>

<p>I would use nginx instead of Apache2, but for a server only accessible internally that will probably not see a lot of traffic, it was much easier and faster to just set up Apache2 and passenger than start unicorns for the Graphite and Graylog web interfaces.</p>

<h2>app</h2>

<p><code>ruby
run_list %W(
  recipe[imagemagick]
  recipe[nginx]
  recipe[unicorn]
)
</code></p>

<p>Probably among the least surprising roles. The application servers use nginx and unicorn for blazingly fast speed. Make sure to add the nginx collectd plugin to this server for additional metrics and monitoring:</p>

<p>```ruby
default_attributes 'collectd' => {</p>

<pre><code>'plugins' =&gt; {
  'nginx' =&gt; { }
}
</code></pre>

<p>  }
```</p>

<p>And those are the basic roles I developed. Because Everest is a complicated application there are a number of roles that I don't discuss here, but this should be more than enough to get anyone started for some good, sensible Chef cookbooks to use with Rails.</p>

<h1>Security &amp; Safety</h1>

<p>Before you deploy a server using any of these roles, make sure to keep security and safety in mind. A lot of these tools (like Graphite and Graylog2) allow web access and run servers with potential security vulnerabilities. Lock them behind Apache2 basic access, change your EC2 security group settings to allow only certain IP addresses access, and establish a VPN for your internal network. With logs, statistics, and other business-sensitive information, you can never be too security-conscious.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Cache Counters in Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/29/dynamic-cache-counters-in-rails/"/>
    <updated>2012-10-29T17:55:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/29/dynamic-cache-counters-in-rails</id>
    <content type="html"><![CDATA[<p>I spent a frustrating hour today searching for a way to do dynamic cache counters in Rails.</p>

<p>The problem is best summed up in a use case. I have a model called votes. A vote can be an upvote or a downvote; I set a column called <code>type</code> indicating what it is. Though I call the column <code>type</code> there's no need for STI here -- there's really only one model, after all. However, it is polymorphic. You can vote up any kind of content on the site. I want to cache the number of upvotes and downvotes separately for that content. Unfortunately, the out-of-the-box Rails counter mechanism doesn't let you do this. According to the <code>counter_cache</code> documentation, you must either specify <code>true</code> or the name of the column you're caching under. You're out of luck if you want to change it dynamically.</p>

<p>This, then, is the solution I came up with to allow dynamic cache counters.</p>

<!-- more -->


<p>The most ideal way to do this is to hook into the existing <a href="http://api.rubyonrails.org/classes/ActiveRecord/CounterCache.html">ActiveRecord CounterCache</a> module. Given that, the code is quite simple, really:</p>

<p>```ruby
class Vote &lt; ActiveRecord::Base
  belongs_to :voteable, polymorphic: true, touch: true</p>

<p>  after_create :increment_counters
  after_destroy :decrement_counters</p>

<p>  [:increment, :decrement].each do |type|</p>

<pre><code>define_method("#{type}_counters") do
  voteable_type.classify.constantize.send("#{type}_counter", "#{self.type}votes_count".to_sym, self.voteable_id)
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The CounterCache module has two methods we care about here: <code>increment_counter</code> and <code>decrement_counter</code>. We manually trigger these methods on the parent object's class after a vote is created or destroyed; note that I don't intend to change the type of the vote, but if you do, you'll also need an after_save callback to decrement one counter and increment another. So with these callbacks, if I have a vote with type <code>up</code>, it will call <code>increment_counter</code> on the column <code>upvotes_count</code> with the ID of the saving object.</p>

<p>This code assumes that the parent model will correctly have a counter column of the appropriate type defined.</p>

<p>Instead of this quasi-hack, I briefly investigated patching Rails to allow the <code>counter_cache</code> option to accept a lambda or proc, but doing so would have involved a lot of changes and would probably be stuck forever in Github issues. This change, while not exactly as clean and portable, does the job with a minimum of fuss.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns V: Searchable with Elasticsearch]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/25/rails-concerns-v-searchable-with-elasticsearch/"/>
    <updated>2012-10-25T12:50:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/25/rails-concerns-v-searchable-with-elasticsearch</id>
    <content type="html"><![CDATA[<p>I use the wonderful <a href="http://www.elasticsearch.org/">elasticsearch</a> for my searching needs. I described in <a href="http://joshsymonds.com/blog/2012/03/25/elasticsearch-and-percolation-in-rails/">previous</a> <a href="http://joshsymonds.com/blog/2012/04/15/testing-elasticsearch-in-rails-with-tire/">posts</a> how I use and test elasticsearch in general; but in my current project, I found myself using elasticsearch in a very similar way across all my models. Call me crazy, but that sounds like a concern to me!</p>

<p>As a result of this concern, I ended up having a really neat abstraction that allowed me to search across all my models using elastcisearch's <a href="http://www.elasticsearch.org/guide/reference/api/multi-index.html">multi-index search functionality</a>. The end result of this concern was not only less duplicated code; it was a useful utility function that acted on all the models that implemented it.</p>

<!-- more -->


<h2>The Setup</h2>

<p>I have multiple models that are searchable, all of which are searchable in somewhat similar ways. For example, users need left-handed ngram indexing for their names (for autocompletion), but also full searching on the same field; similarly, the titles of content work almost exactly the same way. The only difference between the two was the weights they should use, so I set them up similarly in tire:</p>

<p>```ruby
class User</p>

<p>  settings ElasticSearchAnalysis do</p>

<pre><code>mapping do
  indexes :name, type: 'multi_field', fields: {
    name: {type: 'string', analyzer: 'full', boost: 3},
    partial: {type: 'string', search_analyzer: 'full', index_analyzer: 'partial'}
  }
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ElasticSearchAnalysis</code> is a constant that contains the settings for the partial and full analyzers referenced in the mappings. Of course, I index more fields for content, but ultimately I was using the searchers in the two models in a very similar way: a boolean should of all the different mappings conjoined together. As I was working on the code for the two different models, it was looking more and more similar... and then when I added in searching to tags and it was just about the same thing, I figured it was time to come up with a concern. I elected to call it <code>searchable</code> and wanted it to look something like this:</p>

<p>```ruby
class User
  include Searchable</p>

<p>  settings ElasticSearchAnalysis do</p>

<pre><code># elasticsearch settings here
</code></pre>

<p>  end</p>

<p>  searchable :name, 'name.partial'
end
```</p>

<p>Where I could simply list all the fields I wanted to search.</p>

<h2>The Module</h2>

<p>This is the module I came up with to express this.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
end

def search(term, options = {})
  searcher(term, :text, options)
end

private

def searcher(term, type, options = {}, field_options = {})
  fields = Array(@search_fields)

  self.tire.search(options.merge(load: true)) do
    query do
      boolean do
        fields.each do |field|
          should {send(type, field, term, field_options)}
        end
      end
    end
  end.results

end
</code></pre>

<p>  end
end
```</p>

<p>If you've been following my series on concerns, this shouldn't be very surprising stuff. When you call searchable, the fields are added to an instance variable: then, when you call search on the model, we concatenate all the fields together and boolean search across on each of them. So once this is all set up, you'd use it like this:</p>

<p><code>ruby
User.search('Josh Symonds')
</code></p>

<p>Which will generate a tire query like this:</p>

<p>```ruby
User.tire.search(load: true) do
  query do</p>

<pre><code>boolean do
  should text('name', 'Josh Symonds')
  should text('name.partial', 'Josh Symonds')
end
</code></pre>

<p>  end
end
```</p>

<h2>Extending to More Like This</h2>

<p>Of course, that <code>searcher</code> private method is just begging for another use. Why abstract it out so cleverly and not do something with it? Let's use elasticsearch's <a href="http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query.html">more like this query</a> so we can quickly find objects like each other (to display in an attractive sidebar, for example). <strong>For this to work, in addition to having tire in your Gemfile, you'll also need tire-contrib</strong>. So make sure you have it there or else this will explode.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>...

def more_like(term, options = {})
  searcher(term, :more_like_this_field, options, {min_term_freq: 1, min_doc_freq: 2})
end

...
</code></pre>

<p>  end
end
```</p>

<p>Now you can say <code>User.more_like('Josh Symonds')</code> and it'll find all documents with a more_like_this query for my name. Clever!</p>

<h2>Searching Across Multiple Models</h2>

<p>If you have a single search field on your site (like in the top navbar), most likely you'll want to search across multiple models with it: the user could be searching for a person, or a piece of content, or a tag. There's no easy way to know for sure what it is they want, so we should search across all of the fields and order the results by their relevance. Though this sounds complicated, with this concern, this is actually surprisingly easy.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
  Searchable.loaded_classes[self.to_s] = fields
end

...
</code></pre>

<p>  end</p>

<p>  def self.loaded_classes</p>

<pre><code>@loaded_classes ||= {}
</code></pre>

<p>  end</p>

<p>  def self.search(term, options = {})</p>

<pre><code>Tire.search(Searchable.loaded_classes.keys.collect {|k| k.downcase.pluralize}.reverse, options.merge(load: true)) do
  query do
    boolean do
      Searchable.loaded_classes.values.flatten.uniq.each do |field|
        should {text field, term}
      end
    end
  end
end.results
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>We changed the <code>searchable</code> method slightly. Now, in addition to adding to an instance variable, it adds to a hash that the module itself keeps track of: this hash contains all the models as keys, and all their fields as values. Then, when we use it, it constructs a search across all those models' indexes for all the fields those models should be searching. To give a concrete example, let's say we use <code>Searchable.search('Josh Symonds')</code> and we have indexes on content titles and user names. This is what the resulting tire query will look like:</p>

<p>```ruby
Tire.search(['users', 'contents'], {load: true}) do
  query do</p>

<pre><code>boolean do
  should text('name', 'Josh Symonds')
  should text('name.partial', 'Josh Symonds')
  should text('title', 'Josh Symonds')
  should text('title.partial', 'Josh Symonds')
end
</code></pre>

<p>  end
end
```</p>

<p>If you have some models that should be more relevant (like an exact tag match should be the most relevant result), give those mappings an appropriate boost inside the tire mappings for the model. Also keep in mind this will return an array of potentially very different objects: users and contents, in this case. You should either make sure they're all duck-typed correctly together, or check their type before acting on them. Finally, this will only work in development if you load each model before calling <code>Searchable.search</code>. Just entering the constant name of the model should be enough, but if you don't, then the module won't know to search with that model. Such is the danger of lazy loading in development.</p>

<h2>The Final Module</h2>

<p>For your reference, this is the final module with all code included.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
  Searchable.loaded_classes[self.to_s] = fields
end

def search(term, options = {})
  searcher(term, :text, options)
end

def more_like(term, options = {})
  searcher(term, :more_like_this_field, options, {min_term_freq: 1, min_doc_freq: 2})
end

private

def searcher(term, type, options = {}, field_options = {})
  fields = Array(@search_fields)

  self.tire.search(options.merge(load: true)) do
    query do
      boolean do
        fields.each do |field|
          should {send(type, field, term, field_options)}
        end
      end
    end
  end.results

end
</code></pre>

<p>  end</p>

<p>  def self.loaded_classes</p>

<pre><code>@loaded_classes ||= {}
</code></pre>

<p>  end</p>

<p>  def self.search(term, options = {})</p>

<pre><code>Tire.search(Searchable.loaded_classes.keys.collect {|k| k.downcase.pluralize}.reverse, options.merge(load: true)) do
  query do
    boolean do
      Searchable.loaded_classes.values.flatten.uniq.each do |field|
        should {text field, term}
      end
    end
  end
end.results
</code></pre>

<p>  end</p>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns IV: Class Methodable]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable/"/>
    <updated>2012-10-22T14:27:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable</id>
    <content type="html"><![CDATA[<p>In my application, seed data is an unfortunate necessity. I don't like it but it's there, and it's tightly integrated into many parts of the app (dropdowns, navigational links, and so on). Finding that seed data also tends to be rather ugly and long, unfortunately. Who wants to type <code>Tag.find_by_name('Health &amp; Wellness')</code> or one of the finder variations every time you're looking for something? Not me, that's for sure. I found myself aliasing these finders constantly as class methods: so, the above would be much more easily referenced as <code>Tag.health_wellness</code>.</p>

<p>Once I started duplicating this functionality across models I knew I had a concern. This is the module I came up with to encapsulate it.</p>

<!-- more -->


<h2>Methodizing Names</h2>

<p>The first problem with a concern like this is that it's no easier to call class methods that have weird characters in them. You can do <code>Tag.send('Health &amp; Wellness')</code> but the goal here is to eliminate intervening calls, so that we end up with <code>Tag.health_wellness</code>. Having <code>send</code> in there looks weird and doesn't seem very clean.</p>

<p>I opted to fix this with a new String method I called <code>methodize</code>. Put it in your lib folder and Rails will load it when the application starts.</p>

<p>```ruby
class String
  def methodize</p>

<pre><code>self.gsub(/\s/, '').downcase.gsub(/[^a-z0-9]/, '_')
</code></pre>

<p>  end
end
```</p>

<h2>Setting a Scope</h2>

<p>The models that employ this concern will probably have different columns you'll want to find them by. One might be called 'name', whereas another might be 'title' or 'slug'. To get around these differences, our concern will assume that each model will have a scope that smooths over these differences. I called that scope 'named'.</p>

<p><code>ruby
class Tag
  scope :named, lambda {|n| where(name: n.downcase)}
end
</code></p>

<h2>Creating the Concern</h2>

<p>The concern itself is quite simple. It consists of one method, <code>class_methodable</code>. We call that with an array of names that we want to turn into class methods. For each of those, we define a singleton method that sets or gets a class variable of the value we're looking for. The code itself follows:</p>

<p>```ruby
module ClassMethodable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def class_methodable(methods)

  methods.each do |method|
    define_singleton_method(method.to_s.methodize) do
      v = "@@#{method.to_s.methodize}"

      if class_variable_defined?(v)
        class_variable_get(v)
      else
        class_variable_set(v, self.named(method.to_s).first)
      end
    end
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Using It</h2>

<p>Now that everything's in place, actually using the concern is quite simple. In our class:</p>

<p>```ruby
class Tag
  include ClassMethodable</p>

<p>  class_methodable 'Health &amp; Wellness', 'Relationships', 'Other Stuff'
end
```</p>

<p>And in our code:</p>

<p><code>ruby
Tag.relationships # =&gt; Tag.named('Relationships')
Tag.health_wellness # =&gt; Tag.named('Health &amp; Wellness')
Tag.other_stuff # =&gt; Tag.named('Other Stuff')
</code></p>

<p>Now we can reference our seed data quickly and cleanly, without having to resort constantly to finders.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unobtrusive JavaScript Facebook-Style More Button]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button/"/>
    <updated>2012-10-14T21:20:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button</id>
    <content type="html"><![CDATA[<p>I spent awhile yesterday Googling for a Facebook-style more button with a graceful fallback: something where, if the user didn't have JavaScript, they'd still see something sensible... but if they did, they'd get a sweet fade-in of more content appended right to the content container. Oh, and I also didn't want to write separate views for JSON returns, so it had to deal with HTML returns and strip out the unnecessary bits.</p>

<p>I didn't find anything, so I took a crack at creating it myself. This is the result.</p>

<!-- more -->


<h2>How to Use It</h2>

<p>Before coding I sat down and tried to figure out how this beast would work.</p>

<p>Because it was unobtrusive, it should work on standard links, replacing them with an AJAX-y alternative if they have appropriate attributes. I hit on a link that looked like this:</p>

<p>```ruby
&lt;%= link_to 'More...'.html_safe, root_path(page: @page + 1),</p>

<pre><code>class: 'next_page', 'data-selector' =&gt; '.articles .article',
'data-container' =&gt; '.articles'%&gt;
</code></pre>

<p>```</p>

<p>If the link has <code>data-selector</code> and <code>data-container</code> attributes, it's supposed to be an AJAX more button. The selector tells the script what to look for in the new page; the container tells it where to append the newly found elements. With this use case in hand, I proceeded to coding.</p>

<h2>The Code</h2>

<p>I apologize in advance if there's a cleaner way to do this. My CoffeeScript is pretty weak.</p>

<p>```coffeescript
$(document).ready ->
  $('[data-selector]').click (event) -></p>

<pre><code>element = $(this)
url = element.attr 'href'
return false unless url
container = $(element.attr 'data-container')
selector = element.attr 'data-selector'
more = true

$.ajax
  url: url
  success: (data) -&gt;
    elements = $($(data).find(selector))
    if elements.length == 0
      element.html('All content loaded')
             .addClass('done')
             .removeAttr('href')
    else
      container.append elements
      elements.css opacity: 0
      elements.imagesLoaded (event) -&gt;
        elements.animate opacity: 1
        element.attr('href', $(data).find('[data-selector]').attr('href')).
                html('More &amp;raquo;')
        container.masonry 'appended', elements, true if element.attr('data-masonry')

  beforeSend: -&gt;
    element.html('Loading more...')
           .addClass('loading')

return false
</code></pre>

<p>```</p>

<p>This should be pretty straightforward: we find the URL of the next page from the href of the link itself, and also the container we're adding elements to and the selector. We make an AJAX request for the new page and parse it for the selector, appending each result to the container and fading them in once all the images have loaded. Afterwards, we update the URL to request the next new page of content if someone clicks on the "More" button again -- or we disable the "More" button if we found no content.</p>

<p>Overall pretty simple but I was satisfied with this solution. Oh, and there's a line there for integration into the really excellent <a href="http://masonry.desandro.com/">jQuery Masonry</a> script, if you include a data-masonry attribute on your link element.</p>
]]></content>
  </entry>
  
</feed>
