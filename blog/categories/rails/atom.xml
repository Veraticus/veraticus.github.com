<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-11-25T21:01:15-06:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic Cache Counters in Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/29/dynamic-cache-counters-in-rails/"/>
    <updated>2012-10-29T17:55:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/29/dynamic-cache-counters-in-rails</id>
    <content type="html"><![CDATA[<p>I spent a frustrating hour today searching for a way to do dynamic cache counters in Rails.</p>

<p>The problem is best summed up in a use case. I have a model called votes. A vote can be an upvote or a downvote; I set a column called <code>type</code> indicating what it is. Though I call the column <code>type</code> there's no need for STI here -- there's really only one model, after all. However, it is polymorphic. You can vote up any kind of content on the site. I want to cache the number of upvotes and downvotes separately for that content. Unfortunately, the out-of-the-box Rails counter mechanism doesn't let you do this. According to the <code>counter_cache</code> documentation, you must either specify <code>true</code> or the name of the column you're caching under. You're out of luck if you want to change it dynamically.</p>

<p>This, then, is the solution I came up with to allow dynamic cache counters.</p>

<!-- more -->


<p>The most ideal way to do this is to hook into the existing <a href="http://api.rubyonrails.org/classes/ActiveRecord/CounterCache.html">ActiveRecord CounterCache</a> module. Given that, the code is quite simple, really:</p>

<p>```ruby
class Vote &lt; ActiveRecord::Base
  belongs_to :voteable, polymorphic: true, touch: true</p>

<p>  after_create :increment_counters
  after_destroy :decrement_counters</p>

<p>  [:increment, :decrement].each do |type|</p>

<pre><code>define_method("#{type}_counters") do
  voteable_type.classify.constantize.send("#{type}_counter", "#{self.type}votes_count".to_sym, self.voteable_id)
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The CounterCache module has two methods we care about here: <code>increment_counter</code> and <code>decrement_counter</code>. We manually trigger these methods on the parent object's class after a vote is created or destroyed; note that I don't intend to change the type of the vote, but if you do, you'll also need an after_save callback to decrement one counter and increment another. So with these callbacks, if I have a vote with type <code>up</code>, it will call <code>increment_counter</code> on the column <code>upvotes_count</code> with the ID of the saving object.</p>

<p>This code assumes that the parent model will correctly have a counter column of the appropriate type defined.</p>

<p>Instead of this quasi-hack, I briefly investigated patching Rails to allow the <code>counter_cache</code> option to accept a lambda or proc, but doing so would have involved a lot of changes and would probably be stuck forever in Github issues. This change, while not exactly as clean and portable, does the job with a minimum of fuss.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns V: Searchable with Elasticsearch]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/25/rails-concerns-v-searchable-with-elasticsearch/"/>
    <updated>2012-10-25T12:50:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/25/rails-concerns-v-searchable-with-elasticsearch</id>
    <content type="html"><![CDATA[<p>I use the wonderful <a href="http://www.elasticsearch.org/">elasticsearch</a> for my searching needs. I described in <a href="http://joshsymonds.com/blog/2012/03/25/elasticsearch-and-percolation-in-rails/">previous</a> <a href="http://joshsymonds.com/blog/2012/04/15/testing-elasticsearch-in-rails-with-tire/">posts</a> how I use and test elasticsearch in general; but in my current project, I found myself using elasticsearch in a very similar way across all my models. Call me crazy, but that sounds like a concern to me!</p>

<p>As a result of this concern, I ended up having a really neat abstraction that allowed me to search across all my models using elastcisearch's <a href="http://www.elasticsearch.org/guide/reference/api/multi-index.html">multi-index search functionality</a>. The end result of this concern was not only less duplicated code; it was a useful utility function that acted on all the models that implemented it.</p>

<!-- more -->


<h2>The Setup</h2>

<p>I have multiple models that are searchable, all of which are searchable in somewhat similar ways. For example, users need left-handed ngram indexing for their names (for autocompletion), but also full searching on the same field; similarly, the titles of content work almost exactly the same way. The only difference between the two was the weights they should use, so I set them up similarly in tire:</p>

<p>```ruby
class User</p>

<p>  settings ElasticSearchAnalysis do</p>

<pre><code>mapping do
  indexes :name, type: 'multi_field', fields: {
    name: {type: 'string', analyzer: 'full', boost: 3},
    partial: {type: 'string', search_analyzer: 'full', index_analyzer: 'partial'}
  }
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ElasticSearchAnalysis</code> is a constant that contains the settings for the partial and full analyzers referenced in the mappings. Of course, I index more fields for content, but ultimately I was using the searchers in the two models in a very similar way: a boolean should of all the different mappings conjoined together. As I was working on the code for the two different models, it was looking more and more similar... and then when I added in searching to tags and it was just about the same thing, I figured it was time to come up with a concern. I elected to call it <code>searchable</code> and wanted it to look something like this:</p>

<p>```ruby
class User
  include Searchable</p>

<p>  settings ElasticSearchAnalysis do</p>

<pre><code># elasticsearch settings here
</code></pre>

<p>  end</p>

<p>  searchable :name, 'name.partial'
end
```</p>

<p>Where I could simply list all the fields I wanted to search.</p>

<h2>The Module</h2>

<p>This is the module I came up with to express this.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
end

def search(term, options = {})
  searcher(term, :text, options)
end

private

def searcher(term, type, options = {}, field_options = {})
  fields = Array(@search_fields)

  self.tire.search(options.merge(load: true)) do
    query do
      boolean do
        fields.each do |field|
          should {send(type, field, term, field_options)}
        end
      end
    end
  end.results

end
</code></pre>

<p>  end
end
```</p>

<p>If you've been following my series on concerns, this shouldn't be very surprising stuff. When you call searchable, the fields are added to an instance variable: then, when you call search on the model, we concatenate all the fields together and boolean search across on each of them. So once this is all set up, you'd use it like this:</p>

<p><code>ruby
User.search('Josh Symonds')
</code></p>

<p>Which will generate a tire query like this:</p>

<p>```ruby
User.tire.search(load: true) do
  query do</p>

<pre><code>boolean do
  should text('name', 'Josh Symonds')
  should text('name.partial', 'Josh Symonds')
end
</code></pre>

<p>  end
end
```</p>

<h2>Extending to More Like This</h2>

<p>Of course, that <code>searcher</code> private method is just begging for another use. Why abstract it out so cleverly and not do something with it? Let's use elasticsearch's <a href="http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query.html">more like this query</a> so we can quickly find objects like each other (to display in an attractive sidebar, for example). <strong>For this to work, in addition to having tire in your Gemfile, you'll also need tire-contrib</strong>. So make sure you have it there or else this will explode.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>...

def more_like(term, options = {})
  searcher(term, :more_like_this_field, options, {min_term_freq: 1, min_doc_freq: 2})
end

...
</code></pre>

<p>  end
end
```</p>

<p>Now you can say <code>User.more_like('Josh Symonds')</code> and it'll find all documents with a more_like_this query for my name. Clever!</p>

<h2>Searching Across Multiple Models</h2>

<p>If you have a single search field on your site (like in the top navbar), most likely you'll want to search across multiple models with it: the user could be searching for a person, or a piece of content, or a tag. There's no easy way to know for sure what it is they want, so we should search across all of the fields and order the results by their relevance. Though this sounds complicated, with this concern, this is actually surprisingly easy.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
  Searchable.loaded_classes[self.to_s] = fields
end

...
</code></pre>

<p>  end</p>

<p>  def self.loaded_classes</p>

<pre><code>@loaded_classes ||= {}
</code></pre>

<p>  end</p>

<p>  def self.search(term, options = {})</p>

<pre><code>Tire.search(Searchable.loaded_classes.keys.collect {|k| k.downcase.pluralize}.reverse, options.merge(load: true)) do
  query do
    boolean do
      Searchable.loaded_classes.values.flatten.uniq.each do |field|
        should {text field, term}
      end
    end
  end
end.results
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>We changed the <code>searchable</code> method slightly. Now, in addition to adding to an instance variable, it adds to a hash that the module itself keeps track of: this hash contains all the models as keys, and all their fields as values. Then, when we use it, it constructs a search across all those models' indexes for all the fields those models should be searching. To give a concrete example, let's say we use <code>Searchable.search('Josh Symonds')</code> and we have indexes on content titles and user names. This is what the resulting tire query will look like:</p>

<p>```ruby
Tire.search(['users', 'contents'], {load: true}) do
  query do</p>

<pre><code>boolean do
  should text('name', 'Josh Symonds')
  should text('name.partial', 'Josh Symonds')
  should text('title', 'Josh Symonds')
  should text('title.partial', 'Josh Symonds')
end
</code></pre>

<p>  end
end
```</p>

<p>If you have some models that should be more relevant (like an exact tag match should be the most relevant result), give those mappings an appropriate boost inside the tire mappings for the model. Also keep in mind this will return an array of potentially very different objects: users and contents, in this case. You should either make sure they're all duck-typed correctly together, or check their type before acting on them. Finally, this will only work in development if you load each model before calling <code>Searchable.search</code>. Just entering the constant name of the model should be enough, but if you don't, then the module won't know to search with that model. Such is the danger of lazy loading in development.</p>

<h2>The Final Module</h2>

<p>For your reference, this is the final module with all code included.</p>

<p>```ruby
module Searchable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def searchable(fields)
  @search_fields = fields
  Searchable.loaded_classes[self.to_s] = fields
end

def search(term, options = {})
  searcher(term, :text, options)
end

def more_like(term, options = {})
  searcher(term, :more_like_this_field, options, {min_term_freq: 1, min_doc_freq: 2})
end

private

def searcher(term, type, options = {}, field_options = {})
  fields = Array(@search_fields)

  self.tire.search(options.merge(load: true)) do
    query do
      boolean do
        fields.each do |field|
          should {send(type, field, term, field_options)}
        end
      end
    end
  end.results

end
</code></pre>

<p>  end</p>

<p>  def self.loaded_classes</p>

<pre><code>@loaded_classes ||= {}
</code></pre>

<p>  end</p>

<p>  def self.search(term, options = {})</p>

<pre><code>Tire.search(Searchable.loaded_classes.keys.collect {|k| k.downcase.pluralize}.reverse, options.merge(load: true)) do
  query do
    boolean do
      Searchable.loaded_classes.values.flatten.uniq.each do |field|
        should {text field, term}
      end
    end
  end
end.results
</code></pre>

<p>  end</p>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Concerns IV: Class Methodable]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable/"/>
    <updated>2012-10-22T14:27:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/22/rails-concerns-iv-class-methodable</id>
    <content type="html"><![CDATA[<p>In my application, seed data is an unfortunate necessity. I don't like it but it's there, and it's tightly integrated into many parts of the app (dropdowns, navigational links, and so on). Finding that seed data also tends to be rather ugly and long, unfortunately. Who wants to type <code>Tag.find_by_name('Health &amp; Wellness')</code> or one of the finder variations every time you're looking for something? Not me, that's for sure. I found myself aliasing these finders constantly as class methods: so, the above would be much more easily referenced as <code>Tag.health_wellness</code>.</p>

<p>Once I started duplicating this functionality across models I knew I had a concern. This is the module I came up with to encapsulate it.</p>

<!-- more -->


<h2>Methodizing Names</h2>

<p>The first problem with a concern like this is that it's no easier to call class methods that have weird characters in them. You can do <code>Tag.send('Health &amp; Wellness')</code> but the goal here is to eliminate intervening calls, so that we end up with <code>Tag.health_wellness</code>. Having <code>send</code> in there looks weird and doesn't seem very clean.</p>

<p>I opted to fix this with a new String method I called <code>methodize</code>. Put it in your lib folder and Rails will load it when the application starts.</p>

<p>```ruby
class String
  def methodize</p>

<pre><code>self.gsub(/\s/, '').downcase.gsub(/[^a-z0-9]/, '_')
</code></pre>

<p>  end
end
```</p>

<h2>Setting a Scope</h2>

<p>The models that employ this concern will probably have different columns you'll want to find them by. One might be called 'name', whereas another might be 'title' or 'slug'. To get around these differences, our concern will assume that each model will have a scope that smooths over these differences. I called that scope 'named'.</p>

<p><code>ruby
class Tag
  scope :named, lambda {|n| where(name: n.downcase)}
end
</code></p>

<h2>Creating the Concern</h2>

<p>The concern itself is quite simple. It consists of one method, <code>class_methodable</code>. We call that with an array of names that we want to turn into class methods. For each of those, we define a singleton method that sets or gets a class variable of the value we're looking for. The code itself follows:</p>

<p>```ruby
module ClassMethodable
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def class_methodable(methods)

  methods.each do |method|
    define_singleton_method(method.to_s.methodize) do
      v = "@@#{method.to_s.methodize}"

      if class_variable_defined?(v)
        class_variable_get(v)
      else
        class_variable_set(v, self.named(method.to_s).first)
      end
    end
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Using It</h2>

<p>Now that everything's in place, actually using the concern is quite simple. In our class:</p>

<p>```ruby
class Tag
  include ClassMethodable</p>

<p>  class_methodable 'Health &amp; Wellness', 'Relationships', 'Other Stuff'
end
```</p>

<p>And in our code:</p>

<p><code>ruby
Tag.relationships # =&gt; Tag.named('Relationships')
Tag.health_wellness # =&gt; Tag.named('Health &amp; Wellness')
Tag.other_stuff # =&gt; Tag.named('Other Stuff')
</code></p>

<p>Now we can reference our seed data quickly and cleanly, without having to resort constantly to finders.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unobtrusive JavaScript Facebook-Style More Button]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button/"/>
    <updated>2012-10-14T21:20:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/14/unobtrusive-javascript-facebook-style-more-button</id>
    <content type="html"><![CDATA[<p>I spent awhile yesterday Googling for a Facebook-style more button with a graceful fallback: something where, if the user didn't have JavaScript, they'd still see something sensible... but if they did, they'd get a sweet fade-in of more content appended right to the content container. Oh, and I also didn't want to write separate views for JSON returns, so it had to deal with HTML returns and strip out the unnecessary bits.</p>

<p>I didn't find anything, so I took a crack at creating it myself. This is the result.</p>

<!-- more -->


<h2>How to Use It</h2>

<p>Before coding I sat down and tried to figure out how this beast would work.</p>

<p>Because it was unobtrusive, it should work on standard links, replacing them with an AJAX-y alternative if they have appropriate attributes. I hit on a link that looked like this:</p>

<p>```ruby
&lt;%= link_to 'More...'.html_safe, root_path(page: @page + 1),</p>

<pre><code>class: 'next_page', 'data-selector' =&gt; '.articles .article',
'data-container' =&gt; '.articles'%&gt;
</code></pre>

<p>```</p>

<p>If the link has <code>data-selector</code> and <code>data-container</code> attributes, it's supposed to be an AJAX more button. The selector tells the script what to look for in the new page; the container tells it where to append the newly found elements. With this use case in hand, I proceeded to coding.</p>

<h2>The Code</h2>

<p>I apologize in advance if there's a cleaner way to do this. My CoffeeScript is pretty weak.</p>

<p>```coffeescript
$(document).ready ->
  $('[data-selector]').click (event) -></p>

<pre><code>element = $(this)
url = element.attr 'href'
return false unless url
container = $(element.attr 'data-container')
selector = element.attr 'data-selector'
more = true

$.ajax
  url: url
  success: (data) -&gt;
    elements = $($(data).find(selector))
    if elements.length == 0
      element.html('All content loaded')
             .addClass('done')
             .removeAttr('href')
    else
      container.append elements
      elements.css opacity: 0
      elements.imagesLoaded (event) -&gt;
        elements.animate opacity: 1
        element.attr('href', $(data).find('[data-selector]').attr('href')).
                html('More &amp;raquo;')
        container.masonry 'appended', elements, true if element.attr('data-masonry')

  beforeSend: -&gt;
    element.html('Loading more...')
           .addClass('loading')

return false
</code></pre>

<p>```</p>

<p>This should be pretty straightforward: we find the URL of the next page from the href of the link itself, and also the container we're adding elements to and the selector. We make an AJAX request for the new page and parse it for the selector, appending each result to the container and fading them in once all the images have loaded. Afterwards, we update the URL to request the next new page of content if someone clicks on the "More" button again -- or we disable the "More" button if we found no content.</p>

<p>Overall pretty simple but I was satisfied with this solution. Oh, and there's a line there for integration into the really excellent <a href="http://masonry.desandro.com/">jQuery Masonry</a> script, if you include a data-masonry attribute on your link element.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seamless POST Logins with Rack Middleware]]></title>
    <link href="http://joshsymonds.com/blog/2012/10/10/seamless-post-logins-with-rack-middleware/"/>
    <updated>2012-10-10T18:47:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/10/10/seamless-post-logins-with-rack-middleware</id>
    <content type="html"><![CDATA[<p>It's not uncommon to have login-required forms accessible to users who aren't logged in -- for example, maybe you're trying to encourage someone to start writing some content without having to bother logging in first. Of course, they have to log in before they can post, but what happens when they push that big "post" button? Or take another example: you have a button to thumbs-up some content. Only logged-in users should be able to thumbs-up any content, but you always want to display the button. But then what happens when someone who's not logged in presses the button? In most Rails applications, they'd be logged in, redirected back to the page they were referred from, and they'd have to click the thumbs-up again.</p>

<p>That sort of sucks. They already clicked it once. Why can't we remember that?</p>

<p>I ran into this problem myself today in the context of the thumbs-up button. After doing some research and realizing there was no great Rails 3 solution to the problem, I decided I would roll one myself. The result is some complicated but awesome Rack middleware that I think would be pretty handy for most Rails developers.</p>

<!-- more -->


<h2>Pre-Controller Setup</h2>

<p>This method is rather login-agnostic; it should work if you're using <a href="https://github.com/plataformatec/devise">Devise</a>, <a href="https://github.com/intridea/omniauth">OmniAuth</a>, <a href="https://github.com/plataformatec/devise/wiki/OmniAuth:-Overview">both</a>, or neither. For the purposes of my examples, however, I'm using OmniAuth.</p>

<p>First, put some code wherever you redirect to force login. I do that when I see a <code>CanCan::AccessDenied</code> error, but you should do it wherever makes sense for you. Here's an example method very similar to the one I use.</p>

<p>```ruby
class ApplicationController</p>

<p>  private</p>

<p>  def redirect_to_login</p>

<pre><code>redirect_to login_path(return_to: request.path, return_post_params: params, return_method: request.method)
</code></pre>

<p>  end
end
```</p>

<p><code>login_path</code> should redirect somewhere sensible: I chose sessions#new. Once there, we reset the session (to prevent any funny business) and then assign a bunch of attractive new session variables.</p>

<p>```ruby
class SessionsController &lt; ApplicationController
  def new</p>

<pre><code>reset_session
session[:return_to], session[:return_post_params], session[:return_method] = params[:return_to], params[:return_post_params], params[:return_method]

redirect_to "/auth/facebook"
</code></pre>

<p>  end
end
```</p>

<p>Since I'm using OmniAuth and Facebook, this will result in the user being logged in. In the login callback -- I chose sessions#create -- we need to do some special detection and redirection.</p>

<p>```ruby
class SessionsController &lt; ApplicationController
  def create</p>

<pre><code>user = User.create(request.env)

if user
  session[:user_id] = user.id
  flash[:success] = "Hi &lt;b&gt;#{user.name}&lt;/b&gt;, you are now logged in."

  if session[:return_method] != 'GET'
    redirect_to '/redirect_back'
  else
    redirect_to session[:return_to] || '/'
  end
else
  redirect_to root_url, flash: {error: 'You could not be logged in.'}
end
</code></pre>

<p>  end
end
```</p>

<p>The interesting portion is <code>redirect_to '/redirect_back'</code>. That's our middleware hook: when the session variables are set correctly, and you go to <code>/redirect_back</code>, the middleware will activate and do a POST to the application. So, in essence, <code>/redirect_back</code> stands in for whatever request you just tried to go. That's why this doesn't work with GET requests: with a GET, the new URL for the page will be <code>/redirect_back</code> regardless of what the page is, which looks pretty weird.</p>

<h2>The Middleware</h2>

<p>```ruby
class RedirectBack</p>

<p>  def initialize(app)</p>

<pre><code>@app = app
</code></pre>

<p>  end</p>

<p>  def call(env)</p>

<pre><code>req = Rack::Request.new(env)

if req.path == '/redirect_back' &amp;&amp; req.session[:return_method] &amp;&amp; req.session[:return_post_params] &amp;&amp;
  req.session[:return_to] &amp;&amp; req.session[:user_id]

  env['CONTENT_TYPE'] = 'application/x-www-form-urlencoded'

  env['REQUEST_METHOD'] = req.session.delete(:return_method)
  env["rack.input"] = StringIO.new(Rack::Utils.build_nested_query(req.session[:return_post_params]))
  req.session.delete(:return_post_params).each do |param, val|
    req.params[param] = val
  end

  new_url = req.session.delete(:return_to)
  ['REQUEST_PATH', 'REQUEST_URI', 'PATH_INFO'].each do |req|
    env[req] = new_url
  end

  req.session[:redirected] = true
end

@app.call(env)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The whole idea of this middleware is to reformat the path and add in all the appropriate params from the session variables, and then call the Rails application with it. Rails believes that -- despite the URL being <code>redirect_back</code> -- we've made a correctly-formatted post and processes it correctly, sending another redirect to the client when it's completed.</p>

<h2>Post-Controller Setup</h2>

<p>The only problem is that, since we're dealing with forms here, Rails needs a CSRF token. Without it, it'll purge the session at the beginning of the request and we'll end up in a redirect loop.</p>

<p>However, remember how we <code>reset_session</code> at sessions#new? We can be confident that this session is not fixated; we cleaned it before entering the middleware, and the middleware only deals with session variables. Provided you don't use the cookie session storage mechanism (and you should not be), you can be sure enough of the user's identity to ignore the authenticity token on this one request.</p>

<p>We also need to ensure that Rails places a new, correct CSRF token into the session. Otherwise users' sessions will be deleted by the CSRF handlers upon their next post, which will seem to have an invalid, old token.</p>

<p>```ruby
class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  skip_before_filter :verify_authenticity_token, :if => :redirected?</p>

<p>  def redirected?</p>

<pre><code>if session[:redirected]
  flash.keep
  session[:return_to], session[:return_post_params], session[:return_method], session[:redirected] = nil
  self.form_authenticity_token
  return true
end
</code></pre>

<p>  end
end
```</p>

<p>As a bonus we also clean out the session a little bit so that <code>/redirect_back</code> won't work again.</p>

<p>And that's that! Now a user can initiate a POST and be automatically logged in, see the POST completed, and be redirected to the output -- all with just one little button press. Though the Rails 2 method of doing this was substantially easier, I think this middleware method has an elegance to it. And the usability certainly can't be beat.</p>
]]></content>
  </entry>
  
</feed>
