<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-07-02T17:59:54-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Concerns I: Starting with Redcarpet]]></title>
    <link href="http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet/"/>
    <updated>2012-07-01T20:32:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/07/01/rails-concerns-i-starting-with-redcarpet</id>
    <content type="html"><![CDATA[<p>Rails concerns are a fancy way of saying Ruby modules. 37signals uses concerns <a href="http://37signals.com/svn/posts/3167-code-spelunking-in-the-all-new-basecamp">a lot in the new Basecamp</a>, and it's easy to see why: separation and recatoring allow you to reuse code more sensibly and test it in only one place. But concerns aren't only for code refuse -- by allowing you to unclutter models, they make it more obvious where code in your application lives. Even though, for example, orders are the only model in your system being shipped, having a concern called Shipping makes it completely obvious that that's where all the functionality for shipping lies... whereas a newcomer to your application would have to search through the order model to find it.</p>

<p>I've been using concerns extensively in GirlsGuideTo's upcoming application, and I figured it'd be an interesting read if I shared the ones I've made so far. They're not too complicated (this first one I'm posting mostly just to illustrate the concept), but but don't let that fool you. They can be super complicated nad really involved -- but more than that, concerns just make your code better, so you should definitely be using them!</p>

<!-- more -->


<h2>Redcarpeted</h2>

<p>A lot of fields in GirlsGuideTo are Markdown encoded by the pretty awesome <a href="https://github.com/tanoku/redcarpet/">Redcarpet</a> gem. These fields occur across models, and rather than copy and paste code all over the place, I extracted the idea of converting fields to and from Markdown into a concern.</p>

<p>```ruby
module Redcarpeted
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def redcarpet(field)
  define_method("#{field}_markdown".to_sym) do
    read_attribute(field)
  end

  define_method("#{field}_html".to_sym) do
    Redcarpet.new(read_attribute(field)).to_html
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><code>ActiveSupport::Concern</code> is the magic that makes concerns so ... magical. Simply by including another module called <code>ClassMethods</code>, <code>ActiveSupport::Concern</code>automatically knows to extend the base class with those methods when it's included.</p>

<p>In this case, this allows you to do something like this in your model:</p>

<p>```ruby
  class Post &lt; ActiveRecord::Base</p>

<pre><code>include Redcarpeted

redcarpet :body
</code></pre>

<p>  end
```</p>

<p>Now your Post has two new methods: <code>body_markdown</code> and <code>body_html</code>, allowing you to quickly and easily access the raw Markdown and formatted HTML for any attribute in your model. (And if you're curious, the reason to bother including a <code>body_markdown</code> method is in case you decide to override the base method <code>body</code> yourself at some future point.)</p>

<p>That's just the starts of Rails concerns, though. Next time I'll post a more complicated example with greater ActiveRecord connectivity that will hopefully be a lot more exciting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/"/>
    <updated>2012-06-28T15:09:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages</id>
    <content type="html"><![CDATA[<p>One of the coolest features of Rails 3.2 is <a href="http://api.rubyonrails.org/classes/ActiveSupport/TaggedLogging.html">tagged logging</a>. Using the UUID tagged logger, you can give each individual request a UUID reference number in order to track individual errors, find them, and smoosh them. It's generally pretty awesome.</p>

<p>But it'd be even awesomer if actual errors in your application referenced this UUID, wouldn't it? Maybe even emailed it to you in exception_notification? Presented it to your users so they could say directly, "I encountered error 123xyz," rather than force you to look through a huge amount of backlog to find their specific exception?</p>

<p>Happily, you can do just this!</p>

<!-- more -->


<h2>Rescue_from Madness</h2>

<p>Doing so requires abusing rescue_from a little bit, though. Set up something like this in your application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from ActionController::UnknownAction, with: :render_404
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>This will prevent any error from rendering the default Rails error pages. Instead we'll set up our own error pages like so:</p>

<p>```ruby
  def render_500(exception)</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message
Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
Rails.logger.fatal exception.backtrace.join("\n")
render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>And finally, in your view, actually include the request's unique identifier:</p>

<p><code>ruby
  &lt;h1&gt;&lt;%= @message.split(/\s/).collect(&amp;:capitalize).join(' ') %&gt; &lt;small&gt;&lt;%= @status %&gt;&lt;/small&gt;&lt;/h1&gt;
  &lt;h3&gt;Error Code: &lt;%= request.env['action_dispatch.request_id'] %&gt; &lt;/h3&gt;
</code></p>

<p>Dynamic error pages like what I'm suggesting are powerful but also dangerous. Static error pages are simpler and more maintainable: if the code executing your error page has an error in it, then your server process will loop until finally throwing a system stack exception. But if you keep your dynamic error pages simple and well-tested, it's pretty unlikely that'll happen. Just be careful when using this system -- maybe even don't render the exception in your usual layout, but render it in an error-specific one -- to reduce the chance of your error pages also erroring, and you'll be golden.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing Sites for Users]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users/"/>
    <updated>2012-06-17T17:52:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users</id>
    <content type="html"><![CDATA[<p>Designing a new site from scratch can be difficult -- not technically, but from a usability perspective. What color will your users like best? How big should your buttons be? Where should advertising be placed? Of course, there are <a href="http://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758">amazing usability books</a> out there, but there are some questions you can only answer through experience. Of course, designing for usability should be one of our top priorities -- and here are three cute little libraries that will help you make your sites awesome, beautiful, and most importantly, usable for your users.</p>

<!-- more -->


<h2>Mailcheck</h2>

<p>The amazing <a href="https://github.com/Kicksend/mailcheck">Mailcheck</a> library is great for any site that accepts email addresses. According to its creators, <a href="http://kicksend.com">Kicksend</a>, <a href="http://blog.kicksend.com/how-we-decreased-sign-up-confirmation-email-bounces-by-50/">Mailcheck reduced email confirmation signup bounces by 50%</a>. Now that's pretty impressive.</p>

<p>I also love Mailcheck's philosophy. The guiding idea here -- that users will make errors, and software should respond efficiently to correct them -- is true no matter what you're making, from an iPhone app to a website. Always remember that users will improperly use your software. Guiding them back to the appropriate path is your responsibility, with libraries like Mailcheck specifically, but also generally through your app's flow and and user experience. Every form field that encounters frequent errors should have a Mailcheck-like check around it; your users will thank you by loving your app even more.</p>

<h2>Chosen</h2>

<p><a href="https://github.com/harvesthq/chosen">Chosen</a> is cute little syntactical sugar that turns select boxes from ugly, long monstrosities into helpful little widgets. Check out the <a href="https://github.com/harvesthq/chosen">sample page</a> to see everything that it can do; if you have a select box on your site (and chances are that you do), then you should be using Chosen to help users select items from it more effectively.</p>

<p>Chosen expresses another important usability concept -- accessibility. Modern software can be ridiculously complicated, but most users don't care at all for complexity: they want information presented to them clearly, and they want to be able to navigate said information sensibly. By turning enormous select lists into hinting dropdowns, Chosen formats information sensibly and allows users to select what they want quickly. Ideal accessibility from a user's perspective.</p>

<h2>Bandit</h2>

<p>There's been a fair amount of <a href="http://www.chrisstucchio.com/blog/2012/bandit_algorithms_vs_ab.html">discussion</a> recently about the <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>, especially as it relates to A/B testing. I've done A/B testing with Rails before but never really enjoyed it; but I recently came across the <a href="https://github.com/bmuller/bandit">bandit</a> gem and I know I'll be using it extensively moving into the future.</p>

<p>Using multi-armed bandit solutions, you can test lots of options at once, and for as long as you like. Gradually the numbers for the test will reflect the reality of user preference: you don't need a set number of tests (as per A/B testing) and you aren't confined to only two options. Ultimately, you don't need to guess what a user wants. You can make some reasonable guesses and set them all up as possibilities, and over time, user choice will guide the direction of your site. And that's pretty awesome.</p>

<p>In the end, usability is about making your software more responsive and more presentable to your audience. Try out these libraries, but more than that, keep in mind the principles that guide them. By following those, you're guaranteed to make software that's much more usable than it would be otherwise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Routing with Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails/"/>
    <updated>2012-05-22T23:08:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails</id>
    <content type="html"><![CDATA[<p>I love Rails' routing system. Quickly and easily connecting English-readable URLs to complicated web actions is one of the joys of working in one of the coolest web frameworks on the Internet. At Synthetic, we're ramping up to get a new site out, and as part of the push for that I implemented some cool dynamic routing. I wanted to briefly summarize how and why I went with the routing choices I did, to illustrate using routes expressively and, hopefully, easily.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Hipstamatic has gear. Lots and lots of gear. We have over 100 lenses, flashes, and films; but from a programmatic perspective they're all really similar -- they all have a name, a description, some assets associated to them... And so they're all lumped together in a single model called <code>Gear</code>. Our new application is intended to let users browse our entire gear collection, and so obviously it has a single controller that (surprise surprise) allows you to see each piece of gear. Thus we wind up with routes like this:</p>

<p><code>
  gear/alfred
  gear/dreampop
  gear/stache
</code></p>

<p>And that's kind of tragic. Each type of gear should have its own route, even if they're all in the same model. Something like this would be both more readable and more expressive:</p>

<p><code>
  lenses/alfred
  flashes/dreampop
  films/stache
</code></p>

<p>Of course, having a controller for each kind of gear would be crazy. Happily, Rails provides some easy routing solutions!</p>

<h2>The Solution</h2>

<p>In our routes.rb, for each kind of resource that we're expecting, we create matching routes:</p>

<p><code>ruby
[:lenses, :films, :flashes, :cases].each do |gear|
  match "#{gear}/:id", :controller =&gt; :gear, :action =&gt; :show, :type =&gt; gear, :as =&gt; gear
end
</code></p>

<p>Let's dissect this routing statement in two steps. For the first, obviously, we're linking a route like <code>lenses/a1</code> or <code>flashes/cherry</code> to the gear controller. Importantly we're also passing a type: either lenses, films, flashes, or cases, instructing the controller which endpoint we want. In said controller, we should make sure that this passed type and the name of the piece of gear match. Otherwise people would go to <code>lenses/dreampop</code> or <code>flashes/alfred</code> and still see the correct resource despite specifying an invalid type and name combination. That would just be madness!</p>

<p>```ruby
class GearController &lt; ApplicationController
  before_filter :find_gear</p>

<p>  private</p>

<p>  def find_gear</p>

<pre><code>@gear = Gear.type(params[:type].to_s.singularize).where(:reference =&gt; params[:id]).first if params[:id]
</code></pre>

<p>  end
end
```</p>

<p>Type is a named scope that matches the passed params[:type] to a database column storing the actual type of gear. So this will try to find a lens or flash or what have you with the appropriate reference name. Simple enough.</p>

<p>For the second part of the above route, the <code>:as =&gt; gear</code> part creates named routes like lenses_path and films_url. With that in mind, it's easy for us to dynamically generate links based only on the gear object. This is the helper that allows us to do so:</p>

<p><code>ruby
def multi_path(obj)
  self.send("#{obj.type.pluralize.downcase}_path".to_sym, obj.reference)
end
</code></p>

<p>So I can use <code>multi_path(Gear.find_by_name('Kaimal Mark II'))</code> and the route will be generated as if I had typed <code>lenses_path</code> instead of <code>multi_path</code>: similarly with any object that responds to type and reference, which happily for me is all gear. This is important because I don't want to have to use a switch in iterated blocks to figure out which path name I want to use. Now I can just use multi_path and be guaranteed that the correct one will be selected.</p>

<p>With only a few lines of code, it's easy to make routes that were previously clunky and unexpressive into sensible, readable endpoints. And you don't have to sacrifice DRY to do so. If you have a lot of data that's expressed through only one controller, consider dynamic routing like this. It's easier for customers to remember URLs that are readable to them, and this is a good way to make that happen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick &amp; Easy User Preferences in Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/16/quick-and-easy-user-preferences-in-rails/"/>
    <updated>2012-05-16T18:11:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/16/quick-and-easy-user-preferences-in-rails</id>
    <content type="html"><![CDATA[<p>My first RubyMotion application is rapidly nearing completion. As it involves user preferences that have to be stored both locally and remotely, I was investigating the available Rails gems for user preferences and really didn't like what was presently out there. I don't really have time to maintain another gem, but maybe someone else has run into this problem and wants a quick and easy solution for creating user preferences. If so, then this code's for you.</p>

<!-- more -->


<h2>Setting Up Preferences</h2>

<p>You need a preference model. It should look like this:</p>

<p>```ruby
class Preference &lt; ActiveRecord::Base
  belongs_to :user</p>

<p>  validates_uniqueness_of :name, :scope => :user_id</p>

<p>  attr_accessible :name, :value
end
```</p>

<p>I used this migration to create it:</p>

<p>```ruby
class CreatePreferences &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :preferences do |t|
  t.string :name, :value
  t.integer :user_id
  t.timestamps
end
</code></pre>

<p>  end
end
```</p>

<p>You might note that the value of all preferences, regardless of if they're supposed to be Boolean or datetime, is a string. Keep this in mind when you have to query this field later. (That is, if you want to search for all preferences where the value is true, you'll want to search for "1". And similarly, doing <code>user.preferences.first.true?</code> will always return <code>true</code>, as any string value is true. So, coder beware!)</p>

<h2>Using Them</h2>

<p>Ideally, this is what we want the user model to look like.</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  include Preferences</p>

<p>  preference :chime, false
  preference :name, "Josh"
  preference :awesome, true</p>

<p>  ...
end
```</p>

<p>Simple but straightforward: we include the module and then define each preference, with its name first and default value second. Ideally we don't want to save default values to the database, since that would just make a lot of unnecessary records.</p>

<h2>The Preferences Module</h2>

<p>So let's make that happen in that <code>include Preferences</code> line! This is the real heart of the preferences engine.</p>

<p>```ruby
module Preferences
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>has_many :preferences
@@preferences = {}
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def preference(name, default)
  preferences = self.class_variable_get(:'@@preferences')
  preferences[name] = default
  self.class_variable_set(:'@@preferences', preferences)
end
</code></pre>

<p>  end</p>

<p>  def read_preference(name)</p>

<pre><code>if p = self.preferences.where(:name =&gt; name).first
  return p
end
return self.preferences.new(:name =&gt; name, :value =&gt; @@preferences[name]) if @@preferences.has_key?(name)
nil
</code></pre>

<p>  end</p>

<p>  def write_preference(name, value)</p>

<pre><code>p = self.preferences.find_or_create_by_name(name)
p.update_attribute(:value, value)
</code></pre>

<p>  end</p>

<p>  def method_missing(method, *args)</p>

<pre><code>if @@preferences.keys.any?{|k| method =~ /#{k}/}
  if method =~ /=/
    self.write_preference(method.gsub('=', ''), *args)
  else
    self.read_preference(method)
  end
else
  super
end
</code></pre>

<p>  end
end
```</p>

<p>This is really pretty simple. Upon inclusion it tells the model that it's a part of that it <code>has_many :preferences</code> and sets up a class variable hash to store preferences and their defaults. When you declare <code>preference :chime, true</code> it records that in the class variable, and then all instances will respond to either <code>user.chime = true</code> or <code>user.write_preference(:chime, true)</code>. You can read values with <code>user.chime</code> or <code>user.read_preference(:chime)</code>. If a value isn't written in the database, it returns the default value instead.</p>

<p>This probably has a level or two of refactoring that could happen around it. Maybe when I have time I will turn it into a more sensible gem, but until then, if anyone needs quick and dirty preferences... here you go.</p>
]]></content>
  </entry>
  
</feed>
