<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-06-28T15:11:22-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic Error Pages]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages/"/>
    <updated>2012-06-28T15:09:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/28/dynamic-error-pages</id>
    <content type="html"><![CDATA[<p>One of the coolest features of Rails 3.2 is <a href="http://api.rubyonrails.org/classes/ActiveSupport/TaggedLogging.html">tagged logging</a>. Using the UUID tagged logger, you can give each individual request a UUID reference number in order to track individual errors, find them, and smoosh them. It's generally pretty awesome.</p>

<p>But it'd be even awesomer if actual errors in your application referenced this UUID, wouldn't it? Maybe even emailed it to you in exception_notification? Presented it to your users so they could say directly, "I encountered error 123xyz," rather than force you to look through a huge amount of backlog to find their specific exception?</p>

<p>Happily, you can do just this!</p>

<!-- more -->


<h2>Rescue_from Madness</h2>

<p>Doing so requires abusing rescue_from a little bit, though. Set up something like this in your application_controller.rb:</p>

<p><code>ruby
unless Rails.application.config.consider_all_requests_local
  rescue_from Exception, with: :render_500
  rescue_from ActionController::RoutingError, with: :render_404
  rescue_from ActionController::UnknownController, with: :render_404
  rescue_from ActionController::UnknownAction, with: :render_404
  rescue_from ActiveRecord::RecordNotFound, with: :render_404
end
</code></p>

<p>This will prevent any error from rendering the default Rails error pages. Instead we'll set up our own error pages like so:</p>

<p>```ruby
  def render_500(exception)</p>

<pre><code>render_exception(500, exception.message, exception)
</code></pre>

<p>  end</p>

<p>  def render_404(exception)</p>

<pre><code>render_exception(404, 'Page not found', exception)
</code></pre>

<p>  end</p>

<p>  def render_exception(status = 500, message = 'Server error', exception)</p>

<pre><code>@status = status
@message = message
Rails.logger.fatal "\n#{exception.class.to_s} (#{exception.message})"
Rails.logger.fatal exception.backtrace.join("\n")
render template: "errors/error", formats: [:html], layout: 'application', status: @status
</code></pre>

<p>  end
```</p>

<p>And finally, in your view, actually include the request's unique identifier:</p>

<p><code>ruby
  &lt;h1&gt;&lt;%= @message.split(/\s/).collect(&amp;:capitalize).join(' ') %&gt; &lt;small&gt;&lt;%= @status %&gt;&lt;/small&gt;&lt;/h1&gt;
  &lt;h3&gt;Error Code: &lt;%= request.env['action_dispatch.request_id'] %&gt; &lt;/h3&gt;
</code></p>

<p>Dynamic error pages like what I'm suggesting are powerful but also dangerous. Static error pages are simpler and more maintainable: if the code executing your error page has an error in it, then your server process will loop until finally throwing a system stack exception. But if you keep your dynamic error pages simple and well-tested, it's pretty unlikely that'll happen. Just be careful when using this system -- maybe even don't render the exception in your usual layout, but render it in an error-specific one -- to reduce the chance of your error pages also erroring, and you'll be golden.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing Sites for Users]]></title>
    <link href="http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users/"/>
    <updated>2012-06-17T17:52:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/06/17/designing-sites-for-users</id>
    <content type="html"><![CDATA[<p>Designing a new site from scratch can be difficult -- not technically, but from a usability perspective. What color will your users like best? How big should your buttons be? Where should advertising be placed? Of course, there are <a href="http://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758">amazing usability books</a> out there, but there are some questions you can only answer through experience. Of course, designing for usability should be one of our top priorities -- and here are three cute little libraries that will help you make your sites awesome, beautiful, and most importantly, usable for your users.</p>

<!-- more -->


<h2>Mailcheck</h2>

<p>The amazing <a href="https://github.com/Kicksend/mailcheck">Mailcheck</a> library is great for any site that accepts email addresses. According to its creators, <a href="http://kicksend.com">Kicksend</a>, <a href="http://blog.kicksend.com/how-we-decreased-sign-up-confirmation-email-bounces-by-50/">Mailcheck reduced email confirmation signup bounces by 50%</a>. Now that's pretty impressive.</p>

<p>I also love Mailcheck's philosophy. The guiding idea here -- that users will make errors, and software should respond efficiently to correct them -- is true no matter what you're making, from an iPhone app to a website. Always remember that users will improperly use your software. Guiding them back to the appropriate path is your responsibility, with libraries like Mailcheck specifically, but also generally through your app's flow and and user experience. Every form field that encounters frequent errors should have a Mailcheck-like check around it; your users will thank you by loving your app even more.</p>

<h2>Chosen</h2>

<p><a href="https://github.com/harvesthq/chosen">Chosen</a> is cute little syntactical sugar that turns select boxes from ugly, long monstrosities into helpful little widgets. Check out the <a href="https://github.com/harvesthq/chosen">sample page</a> to see everything that it can do; if you have a select box on your site (and chances are that you do), then you should be using Chosen to help users select items from it more effectively.</p>

<p>Chosen expresses another important usability concept -- accessibility. Modern software can be ridiculously complicated, but most users don't care at all for complexity: they want information presented to them clearly, and they want to be able to navigate said information sensibly. By turning enormous select lists into hinting dropdowns, Chosen formats information sensibly and allows users to select what they want quickly. Ideal accessibility from a user's perspective.</p>

<h2>Bandit</h2>

<p>There's been a fair amount of <a href="http://www.chrisstucchio.com/blog/2012/bandit_algorithms_vs_ab.html">discussion</a> recently about the <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>, especially as it relates to A/B testing. I've done A/B testing with Rails before but never really enjoyed it; but I recently came across the <a href="https://github.com/bmuller/bandit">bandit</a> gem and I know I'll be using it extensively moving into the future.</p>

<p>Using multi-armed bandit solutions, you can test lots of options at once, and for as long as you like. Gradually the numbers for the test will reflect the reality of user preference: you don't need a set number of tests (as per A/B testing) and you aren't confined to only two options. Ultimately, you don't need to guess what a user wants. You can make some reasonable guesses and set them all up as possibilities, and over time, user choice will guide the direction of your site. And that's pretty awesome.</p>

<p>In the end, usability is about making your software more responsive and more presentable to your audience. Try out these libraries, but more than that, keep in mind the principles that guide them. By following those, you're guaranteed to make software that's much more usable than it would be otherwise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Routing with Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails/"/>
    <updated>2012-05-22T23:08:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/22/dynamic-routing-with-rails</id>
    <content type="html"><![CDATA[<p>I love Rails' routing system. Quickly and easily connecting English-readable URLs to complicated web actions is one of the joys of working in one of the coolest web frameworks on the Internet. At Synthetic, we're ramping up to get a new site out, and as part of the push for that I implemented some cool dynamic routing. I wanted to briefly summarize how and why I went with the routing choices I did, to illustrate using routes expressively and, hopefully, easily.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Hipstamatic has gear. Lots and lots of gear. We have over 100 lenses, flashes, and films; but from a programmatic perspective they're all really similar -- they all have a name, a description, some assets associated to them... And so they're all lumped together in a single model called <code>Gear</code>. Our new application is intended to let users browse our entire gear collection, and so obviously it has a single controller that (surprise surprise) allows you to see each piece of gear. Thus we wind up with routes like this:</p>

<p><code>
  gear/alfred
  gear/dreampop
  gear/stache
</code></p>

<p>And that's kind of tragic. Each type of gear should have its own route, even if they're all in the same model. Something like this would be both more readable and more expressive:</p>

<p><code>
  lenses/alfred
  flashes/dreampop
  films/stache
</code></p>

<p>Of course, having a controller for each kind of gear would be crazy. Happily, Rails provides some easy routing solutions!</p>

<h2>The Solution</h2>

<p>In our routes.rb, for each kind of resource that we're expecting, we create matching routes:</p>

<p><code>ruby
[:lenses, :films, :flashes, :cases].each do |gear|
  match "#{gear}/:id", :controller =&gt; :gear, :action =&gt; :show, :type =&gt; gear, :as =&gt; gear
end
</code></p>

<p>Let's dissect this routing statement in two steps. For the first, obviously, we're linking a route like <code>lenses/a1</code> or <code>flashes/cherry</code> to the gear controller. Importantly we're also passing a type: either lenses, films, flashes, or cases, instructing the controller which endpoint we want. In said controller, we should make sure that this passed type and the name of the piece of gear match. Otherwise people would go to <code>lenses/dreampop</code> or <code>flashes/alfred</code> and still see the correct resource despite specifying an invalid type and name combination. That would just be madness!</p>

<p>```ruby
class GearController &lt; ApplicationController
  before_filter :find_gear</p>

<p>  private</p>

<p>  def find_gear</p>

<pre><code>@gear = Gear.type(params[:type].to_s.singularize).where(:reference =&gt; params[:id]).first if params[:id]
</code></pre>

<p>  end
end
```</p>

<p>Type is a named scope that matches the passed params[:type] to a database column storing the actual type of gear. So this will try to find a lens or flash or what have you with the appropriate reference name. Simple enough.</p>

<p>For the second part of the above route, the <code>:as =&gt; gear</code> part creates named routes like lenses_path and films_url. With that in mind, it's easy for us to dynamically generate links based only on the gear object. This is the helper that allows us to do so:</p>

<p><code>ruby
def multi_path(obj)
  self.send("#{obj.type.pluralize.downcase}_path".to_sym, obj.reference)
end
</code></p>

<p>So I can use <code>multi_path(Gear.find_by_name('Kaimal Mark II'))</code> and the route will be generated as if I had typed <code>lenses_path</code> instead of <code>multi_path</code>: similarly with any object that responds to type and reference, which happily for me is all gear. This is important because I don't want to have to use a switch in iterated blocks to figure out which path name I want to use. Now I can just use multi_path and be guaranteed that the correct one will be selected.</p>

<p>With only a few lines of code, it's easy to make routes that were previously clunky and unexpressive into sensible, readable endpoints. And you don't have to sacrifice DRY to do so. If you have a lot of data that's expressed through only one controller, consider dynamic routing like this. It's easier for customers to remember URLs that are readable to them, and this is a good way to make that happen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick &amp; Easy User Preferences in Rails]]></title>
    <link href="http://joshsymonds.com/blog/2012/05/16/quick-and-easy-user-preferences-in-rails/"/>
    <updated>2012-05-16T18:11:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/05/16/quick-and-easy-user-preferences-in-rails</id>
    <content type="html"><![CDATA[<p>My first RubyMotion application is rapidly nearing completion. As it involves user preferences that have to be stored both locally and remotely, I was investigating the available Rails gems for user preferences and really didn't like what was presently out there. I don't really have time to maintain another gem, but maybe someone else has run into this problem and wants a quick and easy solution for creating user preferences. If so, then this code's for you.</p>

<!-- more -->


<h2>Setting Up Preferences</h2>

<p>You need a preference model. It should look like this:</p>

<p>```ruby
class Preference &lt; ActiveRecord::Base
  belongs_to :user</p>

<p>  validates_uniqueness_of :name, :scope => :user_id</p>

<p>  attr_accessible :name, :value
end
```</p>

<p>I used this migration to create it:</p>

<p>```ruby
class CreatePreferences &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :preferences do |t|
  t.string :name, :value
  t.integer :user_id
  t.timestamps
end
</code></pre>

<p>  end
end
```</p>

<p>You might note that the value of all preferences, regardless of if they're supposed to be Boolean or datetime, is a string. Keep this in mind when you have to query this field later. (That is, if you want to search for all preferences where the value is true, you'll want to search for "1". And similarly, doing <code>user.preferences.first.true?</code> will always return <code>true</code>, as any string value is true. So, coder beware!)</p>

<h2>Using Them</h2>

<p>Ideally, this is what we want the user model to look like.</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  include Preferences</p>

<p>  preference :chime, false
  preference :name, "Josh"
  preference :awesome, true</p>

<p>  ...
end
```</p>

<p>Simple but straightforward: we include the module and then define each preference, with its name first and default value second. Ideally we don't want to save default values to the database, since that would just make a lot of unnecessary records.</p>

<h2>The Preferences Module</h2>

<p>So let's make that happen in that <code>include Preferences</code> line! This is the real heart of the preferences engine.</p>

<p>```ruby
module Preferences
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>has_many :preferences
@@preferences = {}
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def preference(name, default)
  preferences = self.class_variable_get(:'@@preferences')
  preferences[name] = default
  self.class_variable_set(:'@@preferences', preferences)
end
</code></pre>

<p>  end</p>

<p>  def read_preference(name)</p>

<pre><code>if p = self.preferences.where(:name =&gt; name).first
  return p
end
return self.preferences.new(:name =&gt; name, :value =&gt; @@preferences[name]) if @@preferences.has_key?(name)
nil
</code></pre>

<p>  end</p>

<p>  def write_preference(name, value)</p>

<pre><code>p = self.preferences.find_or_create_by_name(name)
p.update_attribute(:value, value)
</code></pre>

<p>  end</p>

<p>  def method_missing(method, *args)</p>

<pre><code>if @@preferences.keys.any?{|k| method =~ /#{k}/}
  if method =~ /=/
    self.write_preference(method.gsub('=', ''), *args)
  else
    self.read_preference(method)
  end
else
  super
end
</code></pre>

<p>  end
end
```</p>

<p>This is really pretty simple. Upon inclusion it tells the model that it's a part of that it <code>has_many :preferences</code> and sets up a class variable hash to store preferences and their defaults. When you declare <code>preference :chime, true</code> it records that in the class variable, and then all instances will respond to either <code>user.chime = true</code> or <code>user.write_preference(:chime, true)</code>. You can read values with <code>user.chime</code> or <code>user.read_preference(:chime)</code>. If a value isn't written in the database, it returns the default value instead.</p>

<p>This probably has a level or two of refactoring that could happen around it. Maybe when I have time I will turn it into a more sensible gem, but until then, if anyone needs quick and dirty preferences... here you go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Elasticsearch in Rails with Tire]]></title>
    <link href="http://joshsymonds.com/blog/2012/04/15/testing-elasticsearch-in-rails-with-tire/"/>
    <updated>2012-04-15T23:38:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/04/15/testing-elasticsearch-in-rails-with-tire</id>
    <content type="html"><![CDATA[<p>In my <a href="http://joshsymonds.com/blog/2012/03/25/elasticsearch-and-percolation-in-rails/">previous entry on elasticsearch</a>, I promised I would elaborate on testing <a href="http://www.elasticsearch.org/">elasticsearch</a> (and <a href="https://github.com/karmi/tire">tire</a>) in Rails applications. There's not really a whole lot of secret sauce to it, but I figured it'd make a good, quick post with some crunchy code for a late night. While writing, though, I realized I could also talk about a small problem I ran into while using tire -- specifically relating to index regeneration. This isn't a major flaw, but it did waste some of my time, so I figured documenting it (prior to fixing it) would be a sensible idea.</p>

<!-- more -->


<h2>Testing Tire</h2>

<p>There are two components to testing tire: the first is emptying the index before tests where the contents of the index matters, and the second is ensuring that you only delete the index you want, rather than your development index (which would be annoying). Deleting the correct index is really easy. You just want something like this in your model:</p>

<p>```ruby
class Photo
  include Tire::Model::Search</p>

<p>  index_name("#{Rails.env}-search-photos")</p>

<p>  ...
end
```</p>

<p>Specifying <code>index_name</code> as dependent on the Rails environment ensures that your development index won't be destroyed by the next bit of code.</p>

<p><code>ruby
def clear_photo_index
  Photo.tire.index.delete
  Photo.tire.index.create(:mappings =&gt; Photo.tire.mapping_to_hash, :settings =&gt; Photo.tire.settings)
  Photo.tire.index.refresh
end
</code></p>

<p>I stuck that code in <code>test_helper.rb</code> and I call it before each of my photo tests. The first line, obviously, deletes the entire index. The second recreates it, using the mappings and settings already specified in the Photo model. And then we refresh it just to make sure that tire agrees with elasticsearch about the indexed fields.</p>

<h2>Caveat Indexor</h2>

<p>Overall, tire and elasticsearch have been joys to use. I have experienced unexpected behavior in tire though, particularly relating to index mappings. Obviously, deleting an index in tire works just as expected -- the index and all its associated data goes away. Also deleted are the field mappings for that index. However, what happens when you try to create a new object without reloading the class that defined it?</p>

<p>Tire still faithfully stores the object into the deleted index. This invokes elasticsearch's <a href="http://www.elasticsearch.org/guide/reference/api/index_.html">automatic index creation</a> logic, which attempts to determine the types of your fields manually. Unfortunately, it never seems to correctly identify geo_point fields properly. For example, this is what my index mapping should look like:</p>

<p><code>ruby
{"photo"=&gt;{"properties"=&gt;{"account_id"=&gt;{"type"=&gt;"string"}, "id"=&gt;{"type"=&gt;"string"}, "lat_lng"=&gt;{"type"=&gt;"geo_point"}, "name"=&gt;{"type"=&gt;"string", "analyzer"=&gt;"snowball"}}}}
</code></p>

<p>But if I delete the index and then insert an object into it, elasticsearch automatically determines the types as follows:</p>

<p><code>ruby
{"photo"=&gt;{"properties"=&gt;{"_type"=&gt;{"type"=&gt;"string"}, "account_id"=&gt;{"type"=&gt;"long"}, "id"=&gt;{"type"=&gt;"long"}, "lat_lng"=&gt;{"type"=&gt;"string"}, "name"=&gt;{"type"=&gt;"string"}}}}
</code></p>

<p>The key difference here is that <code>lat_lng</code> is not a geo_point but is instead a string, which prevents any of the index geolocation queries from being run on it. You can correct this problem by deleting the index and reloading the class in which the index is defined, which causes tire to create the index again from your provided mapping. (Or run the <code>tire.index.create</code> code from above.) But I spent a tiring(pun!) hour trying to figure out why my indexes kept on receiving inappropriate field types before hitting on this as the reason.</p>

<p>Similarly, and possibly more frustratingly, if you are incrementally developing an index, changes to your mapping won't appear in the index until you delete said index and reload its defining class. Again, deleting the index and inserting data immediately will cause elasticsearch to guess the field mappings for your index, with tragically inconsistent results.</p>

<p>I told the very talented <a href="https://github.com/karmi">karmi</a> about this problem and he sensibly suggested I write a failing test for it, though unfortunately I haven't had the time to sit down and really do that. In the meantime, just know that this annoyance exists, and if you're working on tire indexes, make sure you religiously delete the mapping and then reload the class before you attempt to use the index again.</p>
]]></content>
  </entry>
  
</feed>
