<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-03-10T10:21:05-06:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails 3: Arel, Arel_Table, and Squeel]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/10/rails-3-arel%2Carel_table%2C-and-squeel/"/>
    <updated>2012-03-10T10:17:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/10/rails-3-arel,arel_table,-and-squeel</id>
    <content type="html"><![CDATA[<p>Rails 3 provides a lot of really neat functionality, and one of the pieces that looked coolest was Arel -- ActiveRecord's own relational algebra. Finally, we could get rid of SQL in queries and use a clear, syntactic DSL to manage our queries!</p>

<p>Well, in reality, that isn't quite what happened. ActiveRecord's Arel functionality does provide some neat criteria chaining methods, but unfortunately you either end of typing a lot of raw SQL:</p>

<!-- more -->


<p><code>ruby
Model.select("sum(model.column) as 'model_sum'").order("created_at
DESC").where("models.created_at &gt; ?", DateTime.now - 1.day)
</code></p>

<p>Or using unpleasant workarounds to address the underlying Arel for the model:</p>

<p><code>ruby
Model.where(Model.arel_table[:title].matches('%foo%'))
</code></p>

<p>This is just kinda ugly. Happily, there's a Gem that addresses this problem called <a href="https://github.com/ernie/squeel">squeel</a> that makes Arel what, in my mind, it should be. It provides an elegant, simple syntax for creating and managing queries that is sensibly divorced both from the underlying Arel and raw SQL of the database:</p>

<p><code>ruby
Model.where
</code></p>

<p>Much easier to understand! The double-curly braces does kind of suck (this is because it's a hash inside a proc) but it's still a fair but more understandable than the default Arel stuff.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 1.9 Awesomeness Part 1: SecureRandom]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/07/ruby-1-dot-9-awesomeness-part-1-securerandom/"/>
    <updated>2012-03-07T19:07:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/07/ruby-1-dot-9-awesomeness-part-1-securerandom</id>
    <content type="html"><![CDATA[<p>Ruby 1.9 includes a lot of neat stuff, and one of the coolest things is the SecureRandom module.</p>

<p>SecureRandom presents a plethora of useful methods for creating random numbers and strings. You can <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">check out the documentation</a> for a full list, but some of the more personally useful methods I've found are:</p>

<!-- more -->


<ul>
<li><h3>SecureRandom#uuid</h3>

<p><a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a> uses this method to generate random IDs for objects. The resulting random number is supposed to be unique across an enormously large namespace (see the <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> spec for details) and is perfect if you need a universally unique number... say, for generating IDs in a database.</p></li>
<li><h3>SecureRandom#urlsafe_base64</h3>

<p>If you're creating a URL shortener then this method will end up being incredibly useful. The resulting string only includes characters that are URL safe (as the method name suggests), and while the string is not as unique as one generated by UUID, it will still be fairly random. Guaranteeing uniqueness across an application with a small loop would still probably be a wise idea though:</p></li>
</ul>


<p><code>ruby
permalink = loop do
  permalink = SecureRandom.urlsafe_base64(6)
  break permalink unless Model.find_by_permalink(permalink)
end
</code></p>

<ul>
<li><h3>SecureRandom#base64</h3>

<p>As above, except that +, /, and = are included in the output. The addition of three more characters significantly improves the randomness of this method, though, so use it when the resulting string doesn't need to be in a URL.</p></li>
</ul>


<p>Regardless of what you're working on, the new SecureRandom stuff will end up being incredibly useful for you. Go <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">check out the documentation</a> to see some of the other neat stuff it includes!</p>
]]></content>
  </entry>
  
</feed>
