<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Hi, I'm Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2013-11-14T22:51:52-06:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sidekiq + Houston: Production Ready]]></title>
    <link href="http://joshsymonds.com/blog/2013/10/17/sidekiq-plus-houston-production-ready/"/>
    <updated>2013-10-17T12:13:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2013/10/17/sidekiq-plus-houston-production-ready</id>
    <content type="html"><![CDATA[<p>Three months ago, I wrote <a href="http://joshsymonds.com/blog/2013/07/01/sidekiq-plus-houston-persistent-apple-connection-pooling/">Sidekiq + Houston: Persistent Apple Connection Pooling</a>. The code I included there initially worked great but over time all the APN connections I had established would break and not restart themselves appropriately. To correct this issue, I wrapped the APN connection itself in a class that was more resistant to failure. To help those who are using Sidekiq and Houston together in production, here's the code I used to do so.</p>

<!-- more -->


<p>Change the <code>NotifierWorker</code> to look like this:</p>

<p>```ruby</p>

<h1>app/workers/notifier_worker.rb</h1>

<p>require 'apn_connection'</p>

<p>class NotifierWorker
  include Sidekiq::Worker</p>

<p>  APN_POOL = ConnectionPool.new(:size => 2, :timeout => 300) do</p>

<pre><code>APNConnection.new
</code></pre>

<p>  end</p>

<p>  def perform(message, recipient_ids, custom_data = nil)</p>

<pre><code>recipient_ids = Array(recipient_ids)

APN_POOL.with do |connection|
  tokens = User.where(id: recipient_ids).collect {|u| u.devices.collect(&amp;:token)}.flatten

  tokens.each do |token|
    notification = Houston::Notification.new(device: token)
    notification.alert = message
    notification.sound = 'default'
    notification.custom_data = custom_data
    connection.write(notification.message)
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Of course, the big change here is <code>require apn_connection</code> and the extraction of all the logic that had formerly established our connection with Apple. Now we do that in a new class, sensibly called <code>APNConnection</code>:</p>

<p>```ruby</p>

<h1>lib/apn_connection.rb</h1>

<p>class APNConnection</p>

<p>  def initialize</p>

<pre><code>setup
</code></pre>

<p>  end</p>

<p>  def setup</p>

<pre><code>@uri, @certificate = if Rails.env.production?
  [
    Houston::APPLE_PRODUCTION_GATEWAY_URI,
    File.read("#{Rails.root}/config/keys/production_push.pem")
  ]
else
  [
    Houston::APPLE_DEVELOPMENT_GATEWAY_URI,
    File.read("#{Rails.root}/config/keys/development_push.pem")
  ]
end

@connection = Houston::Connection.new(@uri, @certificate, nil)
@connection.open
</code></pre>

<p>  end</p>

<p>  def write(data)</p>

<pre><code>begin
  raise "Connection is closed" unless @connection.open?
  @connection.write(data)
rescue Exception =&gt; e
  attempts ||= 0
  attempts += 1

  if attempts &lt; 5
    setup
    retry
  else
    raise e
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The main difference here is that the <code>write</code> method will raise an error if the connection has become closed -- this happens most frequently when you write a bad device token into the stream, which causes the APN service to disconnect you. Frustratingly the closure is detected on the request <em>following</em> the bad request, meaning that a perfectly good request encounters an error for no particularly good reason. The retry code here will attempt to reopen the connection to Apple five times and resend the message, until eventually it gives up.</p>

<p>Using this method I have a robust, failure-resistant push notification service in production that I (and my customers) are very pleased with indeed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Helper Methods in Sprinkle]]></title>
    <link href="http://joshsymonds.com/blog/2013/10/14/helper-methods-in-sprinkle/"/>
    <updated>2013-10-14T16:03:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2013/10/14/helper-methods-in-sprinkle</id>
    <content type="html"><![CDATA[<p>Recently I've been using <a href="https://github.com/sprinkle-tool/sprinkle">sprinkle</a> a lot in a large client project. Sprinkle is server provisioning software, akin to <a href="http://www.opscode.com/chef/">Chef</a> except much lighter. It's most directly akin to <a href="https://github.com/rubber/rubber">rubber</a>, but rubber's biggest advantage is its pre-built recipes: it's a little finicky to sensibly extend, and those only work well on EC2. Sprinkle is built for extension, customizability, and platform agnosticism, but comes with no recipes at all by default. Tradeoffs!</p>

<p>Sprinkle (and rubber) are very different from most other server provisioning software I've used -- on the one hand, by leveraging Capistrano for server communication (or SSH or Vlad if you prefer), it remains extremely light and focused on just provisioning. But on the other, it inherits most of Capistrano's downsides too: primary among them is that it's easy to repeat yourself if you're not careful. So I wanted to post a quick tip for other people using sprinkle on how to DRY it up just a little bit.</p>

<!-- more -->


<p>Let's say you have a helper method you want to include in all policies, packages, and verifiers. Make a module to contain it, something like this:</p>

<p>```ruby</p>

<h1>sprinkle/config/helpers.rb</h1>

<p>module Sprinkle
  module Helpers</p>

<pre><code>def templates
  path = File.expand_path('../../', __FILE__)
  "#{path}/templates" # sprinkle/templates/
end
</code></pre>

<p>  end
end
```</p>

<p>The problem is that to use this helper method in a lot of different places requires a little bit of work. You can't just do something like this:</p>

<p>```ruby</p>

<h1>sprinkle/policies/base.rb</h1>

<p>policy :base, roles: :web do
  requires :build_essential if File.exists?("#{templates}/build_essential.txt")</p>

<pre><code>                                         # No method error for templates
</code></pre>

<p>end</p>

<p>package :build_essential do
  file "/etc/build_essential.txt",</p>

<pre><code>contents: render("#{templates}/build_essential.txt"), # No method error for templates
sudo: true
</code></pre>

<p>  verify do</p>

<pre><code>has_file "/etc/build_essential.txt"
puts "#{templates}/build_essential.txt" # Contrived example since you'd never really
                                        # just puts something here, but this also
                                        # throws a no method error
</code></pre>

<p>  end
end
```</p>

<p>You need to include the <code>Helpers</code> module in each class: policy, packages, and verifiers. That's easy enough to do. After you define your helper, do something like this:</p>

<p>```ruby</p>

<h1>sprinkle/config/helpers.rb</h1>

<p>class Sprinkle::Policy
  include Sprinkle::Helpers
end</p>

<p>module Sprinkle::Package
  class Package</p>

<pre><code>include Sprinkle::Helpers
</code></pre>

<p>  end
end</p>

<p>module Sprinkle
  class Verify</p>

<pre><code>include Sprinkle::Helpers
</code></pre>

<p>  end
end
```</p>

<p>Now your helpers will be available everywhere you expect, allowing you to use them anywhere but still define them in one place.</p>

<p>I'll post some more neat sprinkle tidbits in the future, but this by itself allowed me to significantly dry up my code and enjoy my sprinkle experience quite a lot more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sidekiq + Houston: Persistent Apple Connection Pooling]]></title>
    <link href="http://joshsymonds.com/blog/2013/07/01/sidekiq-plus-houston-persistent-apple-connection-pooling/"/>
    <updated>2013-07-01T21:24:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2013/07/01/sidekiq-plus-houston-persistent-apple-connection-pooling</id>
    <content type="html"><![CDATA[<blockquote><p><strong>I updated the code here based on my production experiences with it in a new post, <a href="http://joshsymonds.com/blog/2013/10/17/sidekiq-plus-houston-production-ready/">Sidekiq + Houston: Production Ready</a>. Check it out after reading this article.</strong></p></blockquote>

<p>Having not updated <a href="http://github.com/Veraticus/rapnd">rapnd</a> in a good long while, I was looking for well-supported, up-to-date solution for persisting long-running connections to Apple's push notification service through a worker. I didn't run into anything offhand, and also haven't posted a helpful code snippet in awhile, so this is how I connected <a href="https://github.com/nomad/houston">Houston</a> and <a href="https://github.com/mperham/sidekiq">Sidekiq</a> to Apple's Push Notification service.</p>

<!-- more -->


<p>From Houston's documentation, we can easily set up a persistent connection with code like this:</p>

<p>```ruby
uri, certificate = if Rails.env.production?
  [</p>

<pre><code>Houston::APPLE_PRODUCTION_GATEWAY_URI,
File.read("/path/to/production_key.pem")
</code></pre>

<p>  ]
else
  [</p>

<pre><code>Houston::APPLE_DEVELOPMENT_GATEWAY_URI,
File.read("/path/to/development_key.pem")
</code></pre>

<p>  ]
end</p>

<p>connection = Houston::Connection.new(uri, certificate, nil)
connection.open
```</p>

<p>Maintaining a persistent connection pool with Sidekiq workers is easy thanks to Sidekiq's integration with <a href="https://github.com/mperham/connection_pool">Connection Pool</a>. We can set that up fairly easily like so:</p>

<p><code>ruby
APN_POOL = ConnectionPool.new(:size =&gt; 2, :timeout =&gt; 300) do
  # above code
end
</code></p>

<p>I didn't want more than two connections since that should suffice for initial load; and a timeout of 5 minutes seemed reasonable enough for me. Ultimately, my worker ended up looking like this:</p>

<p>```ruby
class NotifierWorker
  include Sidekiq::Worker</p>

<p>  APN_POOL = ConnectionPool.new(:size => 2, :timeout => 300) do</p>

<pre><code>uri, certificate = if Rails.env.production?
  [
    Houston::APPLE_PRODUCTION_GATEWAY_URI,
    File.read("/path/to/production_key.pem")
  ]
else
  [
    Houston::APPLE_DEVELOPMENT_GATEWAY_URI,
    File.read("/path/to/development_key.pem")
  ]
end

connection = Houston::Connection.new(uri, certificate, nil)
connection.open

connection
</code></pre>

<p>  end</p>

<p>  def perform(message, token)</p>

<pre><code>APN_POOL.with do |connection|
  notification = Houston::Notification.new(device: token)
  notification.alert = message
  connection.write(notification.message)
end
</code></pre>

<p>  end</p>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Programming III]]></title>
    <link href="http://joshsymonds.com/blog/2012/08/21/introduction-to-programming-iii/"/>
    <updated>2012-08-21T10:56:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/08/21/introduction-to-programming-iii</id>
    <content type="html"><![CDATA[<p>Another in the exciting introduction to programming series! This is looking like it'll be a four-part series; at least, I think I'm running into a wall in terms of complexity that I think defines the end of "introduction." Still, I hope it'll be helpful to someone, and it'll hopefully be a popular class at the Center on Halsted.</p>

<!-- more -->


<h2>Flow Control</h2>

<p>In this lesson, we're going to learn how to give our programs some structure. While your very first program was pretty exciting, it also left a little to be desired. What if you wanted to change what we said based on the person's name or hobby? And how do we make Ruby keep repeating the program without manually pressing the "play" button by ourselves?</p>

<p>We're about to learn the means to do that, and we'll start with a fundamental concept in computer programming: comparisons.</p>

<h3>Comparisons</h3>

<p>Many programs rely on comparisons of data to execute properly. For example, consider y. If you put in your email address and password, it has to figure out if those are actually equivalent to what's been stored on the website. As another example, think of an mp3 player. When the song has played the entire length of its track, it has to automatically move to the next track. To do that sort of thing, computer programs rely on comparisons.</p>

<p>All comparisons return <code>true</code> or <code>false</code>. <code>true</code> and <code>false</code> are special objects in Ruby: we use them all the time, as you'll see very shortly. Let's learn about comparisons in an exciting <em>*exercise</em>.</p>

<ol>
<li><p>Type <code>1 == 1</code>. This is the equality comparison. It checks if two objects are exactly equal to each other. We use two equals here, instead of one, because one equal is for variable assignment (as we learned last lesson). Two equals are for equality comparison.</p></li>
<li><p>Try <code>'string' == 'other string'</code>. Obviously these two strings are different: the comparison returns false.</p></li>
<li><p>Try <code>'mary' == 'mary'</code>. Since these two strings are the same, we get true.</p></li>
<li><p>Try <code>1 &gt; 2</code>. Greater than and less than are other comparison operators: they tell you when numbers are, obviously, greater than or less than other numbers.</p></li>
<li><p>Try <code>2 &lt; 2</code>. Two is not less than two, it is equal to two; so this comparison returns false.</p></li>
<li><p>Try <code>2 &lt;= 2</code>. This is the less than or equal to operator: it has an equivalent greater than or equal to operator, <code>&gt;=</code>.</p></li>
<li><p>Try <code>'cat' &lt; 'dog'</code>. This part is a litle confusing: when you compare strings, it compares the actual byte values of the first differing letters. Thus, on most computers, <code>'z' &gt; 'a'</code> will be true! This can be very unexpected and is a reason why you generally don't use greater than or less than on strings.</p></li>
<li><p>Instead, a common string method that returns <code>true</code> or <code>false</code> is <code>include?</code>. Try <code>'zookeeper'.include?('zoo')</code>. This returns true, because the string 'zookeeper' does indeed contain the substring 'zoo.'</p></li>
</ol>


<p>As I said before, we use <code>true</code> and <code>false</code> all the time: and their primary use is for branching.</p>

<h3>Branching</h3>

<p>Very frequently, you'll want to vary what your program does based on a comparison. If the user enters in the word 'dog', you want to print our 'bark': but if they enter in 'cat', you want to print out 'meow'. We already know how to compare the strings 'dog' and 'cat': but how do we change what our program does based on the result of comparisons?</p>

<p>We use branching! Branching is a simple concept but very powerful. Let's write our second program to understand how we can use branching in Ruby.</p>

<p>```ruby
puts "What animal do you want to hear?"
animal = gets.chomp</p>

<p>if animal == 'cat'
  puts "Meow!"
elsif animal == 'dog'
  puts "Bark."
else
  puts "Moo..."
end
```</p>

<p>Remember <code>puts</code> and <code>gets</code> from our last lesson, along with <code>chomp</code> to get rid of newlines? We're using them again: <code>puts</code> outputs information to the console, whereas <code>gets</code> gets it in. But the new and exciting stuff here is the <code>if</code> statement.</p>

<p>An <code>if</code> statement in Ruby allows us to change what our program does on the fly. When you type <code>if</code>, the first thing afterwards has to be a conditional that evaluates to <code>true</code> or <code>false</code>. If the statement is true, the very next line is executed; in this case, we puts "Meow!".</p>

<p>If that conditional isn't <code>true</code>, however, we skip that line entirely and move along. In this case, the computer moves to the next statement: <code>elsif</code>. As you might have guessed, <code>elsif</code> is computer speak for "else if." In other words, if the first if statement is false, try this one instead. Just like <code>if</code>, <code>elsif</code> takes one condition that must evaluate to <code>true</code> or <code>false</code>, and just like <code>if</code>, if the statement isn't true, it moves on to the next one. We can have as many <code>elsif</code>s as we like after an initial <code>if</code>: the first one that is true, though, will cause the other ones to all be skipped. It's an "else if", after all, not an "and if!"</p>

<p>The final piece of this conditional puzzle is <code>else</code>. If all the previous conditions have been false, then what we've provided in <code>else</code> will be executed. In this case, if you didn't enter in 'cat' or 'dog,' then we assume you must want a cow and we put out "Moo...".</p>

<p>All <code>if</code> statements have to end with an <code>end</code>. A lot of multi-line programming needs an <code>end</code> at the very end: otherwise the computer won't know where the <code>if</code> terminates.</p>

<p>Let's try another new program -- except this time you'll make it on your own. Let's use a new string method, called <code>capitalize</code>. Ask what the user's name is, and then get it from the command line. Check if what they typed is equal to what they typed, capitalized. If it is, then welcome them to Introduction to Programming. If it isn't, ask them to try again with a capitalized name... since the most important part of programming is correct capitalization!</p>

<h3>Looping</h3>

<p>Of course, running this program over and over again isn't exactly the most fun thing in the entire universe. I bet you've heard that computers are great at mindless, repetitive tasks... but here, it's you clicking on that little "play" button making the program run. Doesn't that seem like an injustice?</p>

<p>Happily, we can fix this problem. Let's try another program to illustrate how easy it is to repeat stuff in Ruby.</p>

<p><code>ruby
100.times do
  puts "I love programming!"
end
</code></p>

<p>That should probably leave you breathless, saying "I love programming!" a hundred times. What exactly happened here, though?</p>

<p><code>times</code> is a method on integers that takes a new kind of Ruby construct: a block. A block is a small, encapsulated bit of code that a lot of Ruby methods accept. These methods that want blocks always do something with the code in the block. In this case, <code>times</code> simply repeats the block over and over, for as many times as the integer it was called on.</p>

<p><code>do</code> defines the start of a block; <code>end</code> is, obviously, the end. Everything between the <code>do</code> and the <code>end</code> is part of the block, and in this case will be repeated 100 times.</p>

<p>What if we don't want to repeat this merely 100 times, though? What if we want to repeat something endlessly? For that, let's make a completely new program.</p>

<p>```ruby
puts "This is an endless loop! Type 'q' to quit."</p>

<p>loop do
  response = gets.chomp</p>

<p>  if response == 'q'</p>

<pre><code>break
</code></pre>

<p>  else</p>

<pre><code>puts response
</code></pre>

<p>  end
end
```</p>

<p>This program uses a block to do most of its work: but the method we're using to start that block is <code>loop</code>. As you probably guessed, <code>loop</code> will repeat the programming inside the block endlessly, never exiting if it can help it. The special method <code>break</code> that we use inside the block is one of only two ways to exit a loop that is permanently repeating.</p>

<p>Let's try another loop, but this time, let's "forget" to include a break statement.</p>

<p><code>ruby
loop do
  puts "Sayonara repl.it"
  sleep(1)
end
</code></p>

<p>That sleep method commands the computer to wait for 1 second whenever it encounters it: in this case, the computer will output "Sayonara repl.it", wait one second, and then do it all again.</p>

<p>Oh no! We forgot to include a break statement, and now our computer will repeat this poor program forever. What are we supposed to do?</p>

<h3>The End of Repl.it</h3>

<p>Unfortunately, there's not a whole lot we can do... on repl.it.</p>

<p>We've learned about the basic types of Ruby: integers, strings, and floats. We've learned how to use methods on them, and we've learned about Ruby's basic data structures -- arrays and hashes. We've even learned about variables and comparisons. And through it all, repl.it has been our constant ally and friend.</p>

<p>Now we have to abandon it.</p>

<p>That might sound harsh, but remember that repl.it is only a tool for learning Ruby. Real computer programming takes place not in a browser, but on your own computer. When a program goes haywire on our own computer, we have special tools for terminating it and restoring the system's functionality. But on repl.it, those tools don't work. So as we get into more complicated programming, we'll have to migrate away from repl.it and onto some more complicated tools: but along with additional complexity comes greater power.</p>

<h3>Installing Ruby Locally</h3>

<p>For the purposes of this class, I've installed Ruby on all the computers beforehand. But if you ever want to install Ruby on your own computer at home, it's really simple. Instructions for downloading Ruby can be found on the official Ruby website at ruby-lang.org: just click on the "Download Ruby" button in the upper-right to get started, and the downloader will walk you through the installation process.</p>

<p>To verify that we've installed Ruby correctly, let's open up an important tool that we'll be using a lot during programming: the command prompt. A command prompt is part of an operating system. It lets you type commands into the computer directly: they're powerful but also rather opaque, because you need to know the commands and what they do beforehand.</p>

<p>To start the command prompt, click on the "Start" menu. Then click "Run...", type in "cmd", and press enter.</p>

<p>Welcome to the command prompt.</p>

<p>There are a number of commands you can type here, but we want to start interactive Ruby. Interactive Ruby is the right-hand side of repl.it: a window where we can type Ruby commands and see them executed immediately. To start interactive Ruby, type <code>irb</code> into the command prompt and press "enter." You'll see a window very similar to the one on the right side of repl.it.</p>

<p>Now, let's try that last program again, this time on our own local computer.</p>

<p><code>ruby
loop do
  puts "Sayonara repl.it"
  sleep(1)
end
</code></p>

<p>Oh no, we forgot to put in a break again! But this time we can fix our out-of-control program. Press "Ctrl" and "C" simultaneously to break the program. "Ctrl-C" is a shortcut for programs in the command prompt that instructs them to exit immediately. Computer programmers call this "breaking" or "aborting" the program.</p>

<p>Now we have Ruby on our computer. Interactive Ruby is a great way of writing short snippets of code and testing functionality, and you'll use it frequently for smaller, simpler applications.</p>

<h3>Coding Locally</h3>

<p>Now we understand how to get interactive Ruby back. But being able to write programs and then execute them afterwards was actually pretty helpful too. How do we get back the left-hand side of repl.it, the one that let us write code and then run it all at once?</p>

<p>Most computer programs are actually just text files, so we can just use our favorite text editor! The hard work of converting the text into computer instructions is handled by the language itself, so theoretically you could write a computer program in Microsoft Word if you wanted to. But there are way better programs for programming: they provide shortcuts to run the program, help you remember method names, and provide syntax correction if you get something wrong. Let's use one of those instead.</p>

<p>I've already installed a free program called Notepad++ onto your computers. It does a lot of what I've said above, and as a bonus doesn't cost a dime. You can find out more about it (and download it at home) at its <a href="http://notepad-plus-plus.org/">website</a>. We'll be using Notepad++ to program Ruby, so double click its icon on your desktop to start it up. Let's write a simple program to test it out.</p>

<p>```ruby
loop do
  puts "What's your name?"
  name = gets.chomp</p>

<p>  if name == "Josh"</p>

<pre><code>puts "You're teaching a class!"
</code></pre>

<p>  elsif name == "Alisa"</p>

<pre><code>puts "That's Josh's sister's name."
</code></pre>

<p>  else</p>

<pre><code>puts "Hi, " + name.capitalize
</code></pre>

<p>  end
end
```</p>

<p>The content of this program should be fairly familiar to you by now. Save it and give it a filename of <code>name.rb</code>. .rb is the extension for Ruby programs: it tells the computer that the text file you saved is intended to be run by the Ruby interpreter. Now, just double-click the file in the location you saved it and you'll see it run. Magical!</p>

<p>You can also run the program manually from the command-line. To do so, navigate to the folder in which you saved it by using <code>cd</code> (the command line instruction to change directories). So if you saved it in a folder called "My Documents", you'd use <code>cd "My Documents\"</code> to navigate there. Once you're in the same folder as the program, type <code>ruby name.rb</code> to run the program. This is exactly the same as double-clicking on the program icon as above, except by doing it through the command line you're doing it like a programming pro!</p>

<h3>Next Time</h3>

<p>In our next and last class, we'll learn more about flow control using Ruby's powerful and expressive enumerators. We'll learn about classes, how to write our own classes and methods, and write a couple exciting and awesome programs.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Programming II]]></title>
    <link href="http://joshsymonds.com/blog/2012/08/05/introduction-to-programming-ii/"/>
    <updated>2012-08-05T17:48:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/08/05/introduction-to-programming-ii</id>
    <content type="html"><![CDATA[<p>It took me a long time to author this -- and to update this blog in general, in fact. RubyMotion has turned out to be fun and profitable, but also exhausting; I'm engaged in another RubyMotion project that has taken up most of the free time I used to dedicate to this blog.</p>

<p>Still, I committed to making an entire series, starting with <a href="http://joshsymonds.com/blog/2012/04/24/introduction-to-programming-i/">Introduction to Programming I</a>, and this is the next in that line. I hope someone finds it useful! I actually made edits to the last post to remove references to sandRBox -- I'm using <a href="http://repl.it">repl.it</a> now, since that runs on the individual's browser.</p>

<!-- more -->


<h2>Digging Deeper into Ruby</h2>

<p>In our last lesson, we used an online tool (<a href="http://repl.it">repl.it</a>) to understand the basics of the Ruby programming language. We learned some of the basic objects of Ruby -- integers, strings, and floats -- and we also learned what methods are and how they can be used to manipulate those objects. Today we'll start by learning about variables, a key concept in computer programming. Afterwards, we'll use variables to understand more about Ruby's basic objects, and then we'll discover how we can create and manipulate entirely new classes of objects.</p>

<h3>Variables</h3>

<p>A variable is a way of naming data. Why would you want to do this? In computer programs, you'll need to reference the same piece of data over and over again. Maybe you have a string that's particularly important to you; maybe you want to store the result of a calculation so you can refer to it later; or maybe you have an open file that you need to read data from. Variables let you accomplish these goals and more.</p>

<p>In Ruby, variable names are all lower-case, and they can't contain numbers or spaces. <code>variable</code>, <code>this_is_a_long_name</code>, and <code>specialsauce</code> are all valid variable names. In order to use a variable, you just assign it to any Ruby object with an equal sign, like this: <code>mary = 'little lamb'</code>. Now you can always refer to that same <code>'little lamb'</code> string by using the <code>mary</code> variable. If you type the variable name by itself into repl.it, you'll see its value: so when you type <code>mary</code>, you'll see <code>"little lamb"</code>.</p>

<p>Let's do a quick <strong>exercise</strong> to understand the power and importance of variables in Ruby.</p>

<ol>
<li><p>Try <code>mary = 'little lamb'</code>. Now, type <code>mary</code>. It has the value of <code>'little lamb'</code>. This is how you assign variables.</p></li>
<li><p>Let's put our variable to use! Try <code>mary + 'chop'</code>. <code>mary</code> is exactly equivalent to <code>'little lamb'</code>: essentially, <code>mary</code> is the name of that string, now, and every time you call it by its name you're actually using that string. So when you type <code>mary + 'chop'</code>, you're actually saying <code>'little lamb' + 'chop'</code>.</p></li>
<li><p>Try <code>mary</code> again. Note that even though we saw <code>'little lambchop</code>' previously, <code>mary</code>'s value hasn't changed. The only way to change the value of a variable is to assign it with an equals sign.</p></li>
<li><p>Try <code>mary = mary + 'chop'</code>. Now the variable <code>mary</code> is going to be <code>'little lambchop'</code>, because we assigned it again.</p></li>
<li><p>Try <code>dinner = mary</code>. The variable <code>dinner</code> now has the same value as the variable <code>mary</code>, which is to say, <code>'little lambchop'</code>.</p></li>
<li><p>Let's change what we're having for dinner. Try <code>dinner = 'big lambchop'</code>. We've changed the value of <code>dinner</code>: what do you think's happened to the value of <code>mary</code>?</p></li>
<li><p>Try <code>mary</code> to find out. Are you surprised that its value hasn't changed? Each variable gets its own copy of the object you assigned to it. Changing the value of one variable doesn't affect any other similarly-assigned variables. Even though <code>dinner</code> and <code>mary</code> looked like they had the same value, actually each of them had a copy of the same string.</p></li>
<li><p>Let's use some numbers with variables. Try <code>number = 3</code>. Then do some basic math. Try <code>number + number</code>, <code>number * number</code>, and <code>number / number</code>.</p></li>
<li><p>Finally, let's change our number. Try <code>number = number * 3</code>.</p></li>
</ol>


<p>Reassignment of an existing variable (as in <code>number = number * 3</code>) is an extremely common pattern in any programming language. It's so common, in fact, that Ruby provides some clever shorthand to make it even easier to do.</p>

<p>Let's explore variable reassignment in an <strong>exercise</strong>.</p>

<ol>
<li><p>Try <code>mary = 'little lamb'</code>. Now, try <code>mary += 'chop'</code>. This is exactly equivalent to <code>mary = mary + 'chop'</code>.</p></li>
<li><p>Try <code>number = 3</code>. Now, try <code>number *= 4</code>. This is exactly equivalent to <code>number = number * 4</code>.</p></li>
</ol>


<p>There are shortcuts for division (<code>/=</code>) and subtraction (<code>-=</code>) reassignment as well, if you ever need those.</p>

<p>Now that we understand variables, the rest of Ruby's world opens up before us. The basic types we discussed -- integers, strings, floats, and variables -- form the foundation for the Ruby programming language. Now that we've learned about them, we can learn about some exciting new objects... and then eventually how to create new kinds of objects of our very own!</p>

<h3>Organizing Data</h3>

<p>We know now how we would put in numbers and letters in a Ruby program. But what if you want to organize them? Say you wanted to create a list of names, or perhaps you needed a dictionary of words. What would be the best way to do that?</p>

<p>That's what we'll discover now.</p>

<h3>Arrays</h3>

<p>Arrays are lists of objects. They look like this:</p>

<p><code>["This", "is", 'an', 'array', 123]</code></p>

<p>The brackets around the array are telling you what it is -- an array. The elements of the array are separated by commas. This array has five elements -- four strings and one integer. You can put any object into an array, and an array can be as big as you like. Just keep adding commas and elements inside the brackets until it's as big as you need.</p>

<p>Let's try some <strong>exercises</strong> to understand how to use arrays.</p>

<ol>
<li><p>Let's make a new array and assign it to a variable. Try <code>friends = []</code>. The empty brackets mean this is an empty array.</p></li>
<li><p>Let's learn some handy array methods. Try <code>friends.empty?</code> The sad truth is, presently we have no friends. We can verify that by trying <code>friends.count</code>, which, of course, is zero.</p></li>
<li><p>Being friendless sucks. Let's add a friend to our array. Try <code>friends.&lt;&lt;('tom')</code>. Now our array is <code>['tom']</code>. It has one element, the string 'tom'. The <code>&lt;&lt;</code> method inserts an object onto the end of an array. Because this syntax is used so frequently to add elements to an array, it has a shortcut. You can use <code>friends &lt;&lt; 'tom'</code> -- without the parenthesis or the dot -- in order to directly add an element to an array. This is very similar to the shortcut syntax for addition or subtraction (<code>1 + 1</code> instead of <code>1.+(1)</code>).</p></li>
<li><p>Let's add another friend. Try <code>friends.push('jimmy')</code>. Our friends list is certainly filling up! <code>push</code> and <code>&lt;&lt;</code> do the exact same thing to an array. They accept one argument -- the object to be inserted into the array -- and push it onto the very end.</p></li>
<li><p>When you count an array's elements in Ruby, you always start at zero. That is, the very first object in our array is object 0, not object 1. Let's see what that element is: use <code>friends[0]</code> to see the very first friend. Use <code>friends[1]</code> to see our second friend.</p></li>
<li><p>We can also access the elements of our array, instead of using the <code>[]</code> function, by using some English-soundung methods. Try <code>friends.first</code> to see our first friend, and <code>friends.last</code> to see our last.</p></li>
<li><p>This is all well and good, but let's say we have a fight with Tom and want to remove him from our friends array. Try <code>friends.delete('tom')</code>. The <code>delete</code> method removes every object that's identical to the provided argument, so if we had <code>'tom'</code> more than once in the array, all copies of him would be removed.</p></li>
</ol>


<p>Arrays are used commonly in Ruby to organize data in list format. Because they preserve ordering of their elements -- that is, the first element is always the first, the last element is always the last -- you can encode a lot of information in them and be confident of accessing it later.</p>

<h3>Hashes</h3>

<p>A hash is like a dictionary. In a dictionary, you look up a word -- say, 'zebra' -- and read a definition ('a big white and black striped horse-like animal'). Similarly, in a hash, you look up keys and receive values in return. A key is like the word 'zebra' in a dictionary: it's what you use to look up information in a hash. Values are the definitions: they're what you get back when you look up a word.</p>

<p>Hashes look like this:</p>

<p><code>{'mary' =&gt; 'little lamb', 'freddy' =&gt; 1, 'zebra' =&gt; 'a big white and black striped horse-like animal', 1 =&gt; 3}</code></p>

<p>Hashes are always contained in curly brackets, and each key has a hash rocket <code>=&gt;</code> that points to its value. They're very different from arrays, though: hashes have no internal ordering. In an array, we know the first element will always be first... but inside a hash, there's no guarantee that the element we just added will be the last. Let's try some <strong>exercises</strong> to explore this exciting new data structure.</p>

<ol>
<li><p>First, let's make a new hash and assign it to a variable. Try <code>dictionary = {'zebra' =&gt; 'animal'}</code>. If we provided an empty set of curly braces (<code>{}</code>), we'd have made a blank hash; instead we're starting it with an entry.</p></li>
<li><p>Let's look up a value in our hash. Try <code>dictionary['zebra']</code>. The square bracket notation here is similar to what we used earlier in arrays to look up elements; but here, when we look up an element in our hash, we have to provide the key name we stored it with. If we try <code>dictionary[0]</code>,</p></li>
<li><p>Adding a key and value to our hash is easy. Try <code>dictionary['peacock'] = 'beautiful'</code>. This assigns a new key -- 'peacock' -- to a new value -- 'beautiful'. We can look up that value by using <code>dictionary['peacock']</code>.</p></li>
<li><p>We can see an array of the keys in our hash with <code>dictionary.keys</code>, and an array of values with <code>dictionary.values</code>. Note, as I said earlier, that the ordering of elements in a hash is not preserved -- so the keys and values might not appear in the same positions you'd expect.</p></li>
<li><p>Keys have to be unique in a hash -- if you assign a value to a key that already exists, it will replace that key's existing value. Let's change the value of 'zebra'. Try <code>dictionary['zebra'] = 'striped'</code>. Now the value of 'zebra' is 'striped', instead of 'animal'.</p></li>
<li><p>Finally, data structures can contain other data structures. Let's add an array to our hash. Try <code>dictionary['other_animals'] = ['seahorse', 'human', 'eel']</code>.</p></li>
</ol>


<p>Hashes are a great format for storing information in a way that we want to quickly look up later. Whereas arrays are for lists of things, hashes are very much like dictionaries.</p>

<p>We'll look more at hashes and arrays later, when we discuss further how to manipulate data structures. But as of right now, we now know all the basic types in Ruby! It's time to use what we've learned to create our very first program.</p>

<h3>Our First Program</h3>

<p>We now know enough to write our very first program in Ruby! We need two methods we haven't discussed so far: <code>gets</code> and <code>puts</code>. <code>gets</code> grabs the next line of input from the command line; <code>puts</code> spits out whatever we tell it to the console. Let's use those methods to create a program that automatically tabulates points for us.</p>

<p>In Ruby, you write programs in a text editor. While on repl.it, the text editor is the left-half of the screen that we haven't really covered yet. When you write code in there, and press the 'play' button in the upper right, the code will be executed and you'll see the result on the right-hand side. Let's try entering this in to the text editor half of repl.it:</p>

<p>```ruby
scores ||= {}
puts 'Who just scored points?'
name = gets.chomp
puts 'How many more points did they get?'
points = gets.chomp</p>

<p>scores[name] = points
puts 'The current standings are: ' + scores.inspect
```</p>

<p>Let's dissect this progrma line-by-line to understand what's happening here.</p>

<p>In the first line, we create a hash called <code>scores</code>. The <code>||=</code> syntax only assigns the variable if it hasn't already been assigned: we'll cover how it works more in the next lesson.</p>

<p>In the second line, we ask the user who scored points.</p>

<p>In the third, we actually get the name from the command line. Input from the command line is usually terminated by a return -- but that return isn't helpful for us, so we use a string method called <code>chomp</code> to remove the new line from the end.</p>

<p>In the fourth and fifth lines, we again query the user and chomp their input.</p>

<p>The seventh line performs hash assignment, like we just learned: the score is inserted into the hash so that we can keep track of it.</p>

<p>And finally, in the fifth line, we output the actual scores. <code>inspect</code> returns a view of the object that's easily understandable to humans.</p>

<p>You can run this progrma multiple times. Every time you do, you can add in a new score to the hash; later we'll discover how to have the program automatically loop so that we don't have to keep running it manually.</p>

<h3>Your First Program</h3>

<p>Now that we know a little about Ruby, it's time for you to make your very first program all on your own!</p>

<p>Let's create a boss program. Have it ask you what your name is, and what your hobby is. Then use the string method <code>upcase</code> to have it yell back to you that you should get back to work doing that.</p>

<p>Next time, we'll learn how to control flow through our Ruby programs, and we'll start really digging into what makes the Ruby programming language so cool: enumerators!</p>
]]></content>
  </entry>
  
</feed>
