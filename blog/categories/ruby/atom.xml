<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-03-19T11:01:07-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Classifying and Refactoring Your Code]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code/"/>
    <updated>2012-03-16T00:39:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code</id>
    <content type="html"><![CDATA[<p>Outside of the guiding framework of Rails, it can be difficult to manage your own Ruby code, as I've discovered in the process of creating <a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a>. MVC provides a clear and concise framework that encapsulates the functionality of most web applications really well; but outside of web applications, exactly where and how to put your code is a lot less clear. I thought I'd share some of my experiences and thoughts on doing this in my own Gem in the hopes that the lessons I've learned will aid others.</p>

<!-- more -->


<h2>Hashes = Objects</h2>

<p>In the earlier iterations of Dynamoid, I was passing around almost everything in hashes, and the calculations I was performing on those hashes was growing more and more complicated as I went, with logic flying around my files like a flock of disorganized birds. When I was putting index logic into criteria chains, I realized that keeping indexes as hashes was an enormous mistake... and one I wish I had realized earlier.</p>

<p>As I was refactoring my code I realized that I pass hashes around in a number of places. Hashes work well initially to store small amounts of data, but if you're using them for that purpose you almost certainly want a real object instead. Just whip that hash apart into a class and you'll be surprised how much code will go in there, and how much simpler your application will be for your trouble.</p>

<h2>Refactor Early, Refactor Often</h2>

<p>I tend to be my own harshest critic, but honestly, my first pass at features tends to be messy at best. I make my tests pass (always test first, btw, but that's so fundamental I'm not going to include it as a point) but usually in the most complicated, slowest, unpleasant way possible. Take some time after the tests pass to stare at your code a bit and decide if that's really the best way to go about doing things. Usually a change will jump out at you immediately, but don't be afraid to just come back to the code later if nothing presents itself.</p>

<p>Tests allow you to do this kind of refactoring free of charge. I always imagine tests as the scaffolding around my code; no matter how tall the code gets, with the scaffolding it'll never fall over.</p>

<h2>Document!</h2>

<p>I'm really bad at this one myself, but I'm going to be going back through Dynamoid in the very near future and adding documentation to all my methods. Even if your code is a one-liner, people will read documentation over code every time. So document that code! Especially in a collaborative environment, documentation is critical for making your project easy to contribute to.</p>

<p>I'm sure other things will pop out at me after some thought, but these are the biggest takeaways Dynamoid has given me. Hopefully they'll be of use to someone else as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fnordmetric: Native Rails Metrics]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/13/fnordmetric-native-rails-metrics/"/>
    <updated>2012-03-13T22:05:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/13/fnordmetric-native-rails-metrics</id>
    <content type="html"><![CDATA[<p>Over the weekend I spent some time getting <a href="https://github.com/paulasmuth/fnordmetric">Fnordmetric</a> set up in an application. On the surface it looks really cool and quite nifty, but I ran into some trouble getting it configured how I wanted it and figured I'd make a post about it. I think I might have been struggling against the conventions in it a little too much, but it was still an instructive battle.</p>

<!-- more -->


<h2>Engineize It</h2>

<p>The Gem itself assumes you'll be running it on its own port, presumably redirecting nginx traffic there. But this is 2012 and Rails engines are all the rage -- so why bother with a separate app? Well, I'll get to the reason why later, but mounting it as an engine is pretty simple.</p>

<p>Set up an initializer or something that defines all the Fnord metrics you want, something like <code>config/initializers/fnord.rb</code>
```ruby
require "fnordmetric"</p>

<p>FnordMetric.namespace :analytics do
  gauge :events_total,</p>

<pre><code>:tick =&gt; 1.day.to_i, 
:progressive =&gt; true,
:title =&gt; "Events (total)"
</code></pre>

<p>  event(:"*") do</p>

<pre><code>incr :events_tota
</code></pre>

<p>  end
end</p>

<p>FnordMetric.server_configuration = {
  :redis_url => "redis://localhost:6379",
  :redis_prefix => "fnordmetric",
  :inbound_stream => ["0.0.0.0", "1339"],
  :start_worker => true,
  :print_stats => 3,
  :event_queue_ttl => 120,
  :event_data_ttl => 3600<em>24</em>30,
  :session_data_ttl => 3600<em>24</em>30
}
```</p>

<p>That stuff is copy-pasted from the Github README, so I won't go into explaining it. Note that we do not include FnordMetric.standalone at the bottom, however; we'll be mounting the server ourselves in routes.rb like so:</p>

<p><code>ruby
  mount FnordMetric.embedded, :at =&gt; "/fnord"
</code></p>

<p>Then you can go to localhost:3000/fnord, and tada! Fnord metrics!</p>

<h2>Set Up a Worker</h2>

<p>The difficult, of course, is that each instance of your app will now also spin up its own instance of a FnordWorker, which might not be what you want. I got around this by altering my config/initializers/fnord.rb:</p>

<p><code>ruby
FnordMetric.server_configuration = {
  :redis_url =&gt; "redis://localhost:6379",
  :redis_prefix =&gt; "fnordmetric",
  :inbound_stream =&gt; ["0.0.0.0", "1339"],
  :start_worker =&gt; (Rails.env.development? || ENV['FNORD_WORKER'] ? true : false),
  :print_stats =&gt; 3,
  :event_queue_ttl =&gt; 120,
  :event_data_ttl =&gt; 3600*24*30,
  :session_data_ttl =&gt; 3600*24*30
}
</code></p>

<p>I know some people hate the ternary operator, but I kind of like it. Anyway, this causes the worker to start only if there's an environment variable set to start it or the Rails environment is development. I set up one instance that receives this variable when it starts, and now I only have one worker. Simplicity itself!</p>

<p>Ultimately, I like Fnordmetric, but I'm not using it in my production applications. I feel like there's a level of abstraction to go before it's really usable in big production apps. It's much better at tracking arbitrary metrics than NewRelic -- honestly, trying to shoehorn stats into their system feels silly at times -- but setting up the tracking stuff is a pain, involving a lot of unnecessary repetition. I think that a Fnordmetric2.0 would be awesome, though, so I hope the project sees more love and work. And who knows, if I have some time I'll try contributing to it myself. That's the joy of open source: if you have a good idea, you make it happen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 3: Arel, Arel_Table, and Squeel]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/10/rails-3-arel%2Carel_table%2C-and-squeel/"/>
    <updated>2012-03-10T10:17:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/10/rails-3-arel,arel_table,-and-squeel</id>
    <content type="html"><![CDATA[<p>Rails 3 provides a lot of really neat functionality, and one of the pieces that looked coolest was Arel -- ActiveRecord's own relational algebra. Finally, we could get rid of SQL in queries and use a clear, syntactic DSL to manage our queries!</p>

<p>Well, in reality, that isn't quite what happened. ActiveRecord's Arel functionality does provide some neat criteria chaining methods, but unfortunately you either end of typing a lot of raw SQL:</p>

<!-- more -->


<p><code>ruby
Model.select("sum(model.column) as 'model_sum'").order("created_at
DESC").where("models.created_at &gt; ?", DateTime.now - 1.day)
</code></p>

<p>Or using unpleasant workarounds to address the underlying Arel for the model:</p>

<p><code>ruby
Model.where(Model.arel_table[:title].matches('%foo%'))
</code></p>

<p>This is just kinda ugly. Happily, there's a Gem that addresses this problem called <a href="https://github.com/ernie/squeel">squeel</a> that makes Arel what, in my mind, it should be. It provides an elegant, simple syntax for creating and managing queries that is sensibly divorced both from the underlying Arel and raw SQL of the database:</p>

<p><code>ruby
Model.where
</code></p>

<p>Much easier to understand! The double-curly braces does kind of suck (this is because it's a hash inside a proc) but it's still a fair but more understandable than the default Arel stuff.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 1.9 Awesomeness Part 1: SecureRandom]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/07/ruby-1-dot-9-awesomeness-part-1-securerandom/"/>
    <updated>2012-03-07T19:07:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/07/ruby-1-dot-9-awesomeness-part-1-securerandom</id>
    <content type="html"><![CDATA[<p>Ruby 1.9 includes a lot of neat stuff, and one of the coolest things is the SecureRandom module.</p>

<p>SecureRandom presents a plethora of useful methods for creating random numbers and strings. You can <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">check out the documentation</a> for a full list, but some of the more personally useful methods I've found are:</p>

<!-- more -->


<ul>
<li><h3>SecureRandom#uuid</h3>

<p><a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a> uses this method to generate random IDs for objects. The resulting random number is supposed to be unique across an enormously large namespace (see the <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> spec for details) and is perfect if you need a universally unique number... say, for generating IDs in a database.</p></li>
<li><h3>SecureRandom#urlsafe_base64</h3>

<p>If you're creating a URL shortener then this method will end up being incredibly useful. The resulting string only includes characters that are URL safe (as the method name suggests), and while the string is not as unique as one generated by UUID, it will still be fairly random. Guaranteeing uniqueness across an application with a small loop would still probably be a wise idea though:</p></li>
</ul>


<p><code>ruby
permalink = loop do
  permalink = SecureRandom.urlsafe_base64(6)
  break permalink unless Model.find_by_permalink(permalink)
end
</code></p>

<ul>
<li><h3>SecureRandom#base64</h3>

<p>As above, except that +, /, and = are included in the output. The addition of three more characters significantly improves the randomness of this method, though, so use it when the resulting string doesn't need to be in a URL.</p></li>
</ul>


<p>Regardless of what you're working on, the new SecureRandom stuff will end up being incredibly useful for you. Go <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/securerandom/rdoc/SecureRandom.html">check out the documentation</a> to see some of the other neat stuff it includes!</p>
]]></content>
  </entry>
  
</feed>
