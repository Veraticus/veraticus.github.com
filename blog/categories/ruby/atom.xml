<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Josh Symonds]]></title>
  <link href="http://joshsymonds.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://joshsymonds.com/"/>
  <updated>2012-04-06T12:44:36-05:00</updated>
  <id>http://joshsymonds.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby in the Sandbox: SandRBox]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/31/ruby-in-the-sandbox-sandrbox/"/>
    <updated>2012-03-31T11:19:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/31/ruby-in-the-sandbox-sandrbox</id>
    <content type="html"><![CDATA[<p>I volunteer in the cyber center at the <a href="http://www.centeronhalsted.org/">Center on Halsted</a>. They're always looking for people to teach new classes, so I figured I would teach an introduction to programming class -- an introduction through Ruby. Besides being my favorite computer language, I think Ruby makes a great beginner's language: it has none of the strange, computer-oriented concepts that make most programming languages difficult to learn, and it even reads like pure, simple English. Instead of pointers and variable typing, you have sensible enumerators and object orientation. And also it's super fun.</p>

<p>Unfortunately, getting stuff installed on the computers at the cyber center is kind of a headache. Like most chronically underfunded but well-meaning institutions, there are about three levels of bureaucracy between you and getting anything done. And teaching Ruby without the aid of irb would be next to impossible. So what's a guy to do?</p>

<p>Simple: <a href="http://sandrbox.herokuapp.com/">create irb online</a>.</p>

<!-- more -->


<p>Now, I hear what you're saying: "Josh, that already exists, and it's called <a href="http://tryruby.org/">tryruby.org</a>!" Unfortunately, I don't like tryruby all that much. I have nothing but respect for their mission, but the service itself is achingly slow and frequently it won't work at all. I don't know what they're running it on (the only code I could find on github was months old), but I figured I could whip up something better.</p>

<p><a href="https://github.com/Veraticus/Sandrbox">Turns out I was right</a>. Sandrbox is a simple project that I'm actually pretty proud of; it makes use of some very edge-case metaprogramming concepts to create as secure an irb environment as I could whip up. In addition to removing dangerous methods on classes (and their metaclasses), it has some really nice syntactical sugar that makes it easy to understand where you are in a block. And when the execution of your secure code is done, it restores all the classes and methods that were missing while removing any new ones that were added, guaranteeing that your environment will be exactly the same as before you started executing code.</p>

<p>This is obviously important if you intend to run that code on a server somewhere -- after all, you can't have someone doing something like:</p>

<p><code>ruby
`killall -9 thin` # bad
Kernel.exec("rm -rf /") # worse
</code></p>

<p>These methods when executed in Sandrbox are instead gently sanitized:</p>

<p><code>ruby
Sandrbox.perform(['`killall -9 thin`']).output # =&gt; ["NameError: undefined local variable or method ``' for Kernel:Module"]
Sandrbox.perform(['Kernel.exec("rm -rf /")']).output # =&gt; ["NameError: undefined local variable or method `exec' for Kernel:Module"]
</code></p>

<p>While still allowing you to retain the power and complexity of Ruby:</p>

<p><code>ruby
Sandrbox.perform(['class Foo', 'def test', '"Hi!"', 'end', 'end', 'Foo.new.test']).output # =&gt; [nil, '"Hi!"']
</code></p>

<p>Even cooler is that it automatically does some parsing for you, so that you know when code can be executed or the user is probably not done yet typing:</p>

<p><code>ruby
response = Sandrbox.perform(['class Foo', 'def test'])
response.output # []
response.complete? # false
response.indent_level # 2
response.indent_character # 'def'
</code></p>

<p>I put a small Sinatra app in front of this and made a little site that I also called <a href="http://sandrbox.herokuapp.com/">Sandrbox</a>. I intend to use it in place of irb to teach this introduction to programming course -- it'll make a great tool for putting the power of Ruby in front of people while still being relatively assured that they can't destroy my server (intentionally or accidentally). And the code is really pretty neat, so you should definitely <a href="https://github.com/Veraticus/Sandrbox">check out the repository</a>. I can't say that it's totally secure yet, but it's a damn sight better than uncensored irb, and after a week or two of work I bet I'll be able to get it locked down pretty damn tight.</p>

<p>But until then, go ahead and try to break it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Don't Use Haml]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/22/why-i-dont-use-haml/"/>
    <updated>2012-03-22T13:19:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/22/why-i-dont-use-haml</id>
    <content type="html"><![CDATA[<p>I initially thought of titling this post something more inflammatory, like "Why Haml Sucks" or "Only Losers Use Haml." But the truth is <a href="http://haml-lang.com/">Haml</a> does anything but suck. It's actually quite elegant; the syntax is clean, not needing closing tags is just really cool, and it's very fast to read. It seems like it would be an ideal language to replace HTML, just like SASS and CoffeeScript are abstractions of and (to a certain extent) replacements for CSS and JavaScript, respectively.</p>

<p>So why do I bang my head against my desk every time I see someone using it in a view?</p>

<!-- more -->


<h2>Indentation Sucks (Usually)</h2>

<p>Notice the cute little parenthetical up there? That's because I really do like CoffeeScript, which is just as whitespace-sensitive as Haml. So what's the difference?</p>

<p>CoffeeScript uses indentations to abstract away one of the worst "features" of JavaScript: the dreaded <code>})</code> sequences. Closing arguments and functions again and again is not only a headache, it happens so frequently that some sort of error is inevitable. Strict whitespace rules help us avoid errors in closure. Of course, the same argument can be made about HTML and Haml's whitespace rules, but there's another key difference here.</p>

<p>HTML closures indicate which tag they close. You don't have a forest of <code>)})})}</code>, which even if you indent correctly still won't tell you which parenthesis or bracket they're closing. Instead you have an obvious and syntactic declaration of which tag you're ending when you end it. You can argue that the tag closure is unnecessary (Haml seems largely based on this argument), but you're trading explicit tag closure for explicit whitespace restrictions...</p>

<p>And ultimately (and most damningly), whitespace restrictions make the document harder to read and understand than closing tags. If you have an extremely long page with many nested elements, Haml is very difficult to comprehend and consequently much harder to use.</p>

<h2>If It Ain't Broke...</h2>

<p>SASS and CoffeeScript fix serious errors and oversights in the implementations of their specific languages. CoffeeScript ensures correct lexical scoping of variables; SASS allows variable assignment and better selectors than CSS. Both are enormous improvements on the languages they compile into.</p>

<p>Haml doesn't add anything at all to HTML. There's no special Haml tags that do something HTML couldn't do by itself. It gives you a shortcut for the syntax, but that's essentially it.</p>

<p>And HTML really isn't that bad by itself. The syntax is already fairly clean and clear; it's not like we're lost in a field of, well, parenthesis and curly brackets. Tables can get a little muddy at times, but good HTML and CSS prevent documents from becoming unreadable -- and Haml doesn't offer any interesting or unique tools to improve readability, either.</p>

<h2>Designers Aren't Programmers</h2>

<p>But I think this is the biggest reason I don't use Haml. Frontend designers use CSS, and the best ones employ JavaScript (and program good JavaScript!) -- but every single one is going to be using HTML to create their pages. Eventually, if your site gets big, you're going to want a designer to do some pages for you... and they're not going to be producing Haml, they're going to be producing HTML.</p>

<p>Sure, you can change that HTML to Haml. But let me guarantee you, one day they'll want to change something, and at that point you do one of three things:</p>

<ol>
<li>Show them the Haml site, tell them to do it all in Haml, and pay for them learning it.</li>
<li>Take their design and convert it to Haml yourself and then incorporate it into the page.</li>
<li>Curse your unjust fate and just switch to erb and copypaste their changes in.</li>
</ol>


<p>As I said at the beginning, I like Haml. But it's a markup language for programmers, and ultimately the people who use HTML the most aren't programmers. SASS is barely a programming language, more like a set of syntactical shortcuts; and CoffeeScript appeals to those who program in JavaScript already. Haml just doesn't appeal to the correct audience to use its core feature set, which is a damn shame, because Haml really is pretty cool.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classifying and Refactoring Your Code]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code/"/>
    <updated>2012-03-16T00:39:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/16/classifying-and-refactoring-your-code</id>
    <content type="html"><![CDATA[<p>Outside of the guiding framework of Rails, it can be difficult to manage your own Ruby code, as I've discovered in the process of creating <a href="https://github.com/Veraticus/Dynamoid">Dynamoid</a>. MVC provides a clear and concise framework that encapsulates the functionality of most web applications really well; but outside of web applications, exactly where and how to put your code is a lot less clear. I thought I'd share some of my experiences and thoughts on doing this in my own Gem in the hopes that the lessons I've learned will aid others.</p>

<!-- more -->


<h2>Hashes = Objects</h2>

<p>In the earlier iterations of Dynamoid, I was passing around almost everything in hashes, and the calculations I was performing on those hashes was growing more and more complicated as I went, with logic flying around my files like a flock of disorganized birds. When I was putting index logic into criteria chains, I realized that keeping indexes as hashes was an enormous mistake... and one I wish I had realized earlier.</p>

<p>As I was refactoring my code I realized that I pass hashes around in a number of places. Hashes work well initially to store small amounts of data, but if you're using them for that purpose you almost certainly want a real object instead. Just whip that hash apart into a class and you'll be surprised how much code will go in there, and how much simpler your application will be for your trouble.</p>

<h2>Refactor Early, Refactor Often</h2>

<p>I tend to be my own harshest critic, but honestly, my first pass at features tends to be messy at best. I make my tests pass (always test first, btw, but that's so fundamental I'm not going to include it as a point) but usually in the most complicated, slowest, unpleasant way possible. Take some time after the tests pass to stare at your code a bit and decide if that's really the best way to go about doing things. Usually a change will jump out at you immediately, but don't be afraid to just come back to the code later if nothing presents itself.</p>

<p>Tests allow you to do this kind of refactoring free of charge. I always imagine tests as the scaffolding around my code; no matter how tall the code gets, with the scaffolding it'll never fall over.</p>

<h2>Document!</h2>

<p>I'm really bad at this one myself, but I'm going to be going back through Dynamoid in the very near future and adding documentation to all my methods. Even if your code is a one-liner, people will read documentation over code every time. So document that code! Especially in a collaborative environment, documentation is critical for making your project easy to contribute to.</p>

<p>I'm sure other things will pop out at me after some thought, but these are the biggest takeaways Dynamoid has given me. Hopefully they'll be of use to someone else as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fnordmetric: Native Rails Metrics]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/13/fnordmetric-native-rails-metrics/"/>
    <updated>2012-03-13T22:05:00-05:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/13/fnordmetric-native-rails-metrics</id>
    <content type="html"><![CDATA[<p>Over the weekend I spent some time getting <a href="https://github.com/paulasmuth/fnordmetric">Fnordmetric</a> set up in an application. On the surface it looks really cool and quite nifty, but I ran into some trouble getting it configured how I wanted it and figured I'd make a post about it. I think I might have been struggling against the conventions in it a little too much, but it was still an instructive battle.</p>

<!-- more -->


<h2>Engineize It</h2>

<p>The Gem itself assumes you'll be running it on its own port, presumably redirecting nginx traffic there. But this is 2012 and Rails engines are all the rage -- so why bother with a separate app? Well, I'll get to the reason why later, but mounting it as an engine is pretty simple.</p>

<p>Set up an initializer or something that defines all the Fnord metrics you want, something like <code>config/initializers/fnord.rb</code>
```ruby
require "fnordmetric"</p>

<p>FnordMetric.namespace :analytics do
  gauge :events_total,</p>

<pre><code>:tick =&gt; 1.day.to_i, 
:progressive =&gt; true,
:title =&gt; "Events (total)"
</code></pre>

<p>  event(:"*") do</p>

<pre><code>incr :events_tota
</code></pre>

<p>  end
end</p>

<p>FnordMetric.server_configuration = {
  :redis_url => "redis://localhost:6379",
  :redis_prefix => "fnordmetric",
  :inbound_stream => ["0.0.0.0", "1339"],
  :start_worker => true,
  :print_stats => 3,
  :event_queue_ttl => 120,
  :event_data_ttl => 3600<em>24</em>30,
  :session_data_ttl => 3600<em>24</em>30
}
```</p>

<p>That stuff is copy-pasted from the Github README, so I won't go into explaining it. Note that we do not include FnordMetric.standalone at the bottom, however; we'll be mounting the server ourselves in routes.rb like so:</p>

<p><code>ruby
  mount FnordMetric.embedded, :at =&gt; "/fnord"
</code></p>

<p>Then you can go to localhost:3000/fnord, and tada! Fnord metrics!</p>

<h2>Set Up a Worker</h2>

<p>The difficult, of course, is that each instance of your app will now also spin up its own instance of a FnordWorker, which might not be what you want. I got around this by altering my config/initializers/fnord.rb:</p>

<p><code>ruby
FnordMetric.server_configuration = {
  :redis_url =&gt; "redis://localhost:6379",
  :redis_prefix =&gt; "fnordmetric",
  :inbound_stream =&gt; ["0.0.0.0", "1339"],
  :start_worker =&gt; (Rails.env.development? || ENV['FNORD_WORKER'] ? true : false),
  :print_stats =&gt; 3,
  :event_queue_ttl =&gt; 120,
  :event_data_ttl =&gt; 3600*24*30,
  :session_data_ttl =&gt; 3600*24*30
}
</code></p>

<p>I know some people hate the ternary operator, but I kind of like it. Anyway, this causes the worker to start only if there's an environment variable set to start it or the Rails environment is development. I set up one instance that receives this variable when it starts, and now I only have one worker. Simplicity itself!</p>

<p>Ultimately, I like Fnordmetric, but I'm not using it in my production applications. I feel like there's a level of abstraction to go before it's really usable in big production apps. It's much better at tracking arbitrary metrics than NewRelic -- honestly, trying to shoehorn stats into their system feels silly at times -- but setting up the tracking stuff is a pain, involving a lot of unnecessary repetition. I think that a Fnordmetric2.0 would be awesome, though, so I hope the project sees more love and work. And who knows, if I have some time I'll try contributing to it myself. That's the joy of open source: if you have a good idea, you make it happen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 3: Arel, Arel_Table, and Squeel]]></title>
    <link href="http://joshsymonds.com/blog/2012/03/10/rails-3-arel%2Carel_table%2C-and-squeel/"/>
    <updated>2012-03-10T10:17:00-06:00</updated>
    <id>http://joshsymonds.com/blog/2012/03/10/rails-3-arel,arel_table,-and-squeel</id>
    <content type="html"><![CDATA[<p>Rails 3 provides a lot of really neat functionality, and one of the pieces that looked coolest was Arel -- ActiveRecord's own relational algebra. Finally, we could get rid of SQL in queries and use a clear, syntactic DSL to manage our queries!</p>

<p>Well, in reality, that isn't quite what happened. ActiveRecord's Arel functionality does provide some neat criteria chaining methods, but unfortunately you either end of typing a lot of raw SQL:</p>

<!-- more -->


<p><code>ruby
Model.select("sum(model.column) as 'model_sum'").order("created_at
DESC").where("models.created_at &gt; ?", DateTime.now - 1.day)
</code></p>

<p>Or using unpleasant workarounds to address the underlying Arel for the model:</p>

<p><code>ruby
Model.where(Model.arel_table[:title].matches('%foo%'))
</code></p>

<p>This is just kinda ugly. Happily, there's a Gem that addresses this problem called <a href="https://github.com/ernie/squeel">squeel</a> that makes Arel what, in my mind, it should be. It provides an elegant, simple syntax for creating and managing queries that is sensibly divorced both from the underlying Arel and raw SQL of the database:</p>

<p><code>ruby
Model.where
</code></p>

<p>Much easier to understand! The double-curly braces does kind of suck (this is because it's a hash inside a proc) but it's still a fair but more understandable than the default Arel stuff.</p>
]]></content>
  </entry>
  
</feed>
