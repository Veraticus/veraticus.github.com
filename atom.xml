<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Josh Symonds]]></title>
  <link href="http://Veraticus.github.com/atom.xml" rel="self"/>
  <link href="http://Veraticus.github.com/"/>
  <updated>2012-02-22T15:20:46-06:00</updated>
  <id>http://Veraticus.github.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamoid: An ORM for Amazon's DynamoDB]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/22/dynamoid-an-orm-for-amazons-dynamodb/"/>
    <updated>2012-02-22T15:00:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/22/dynamoid-an-orm-for-amazons-dynamodb</id>
    <content type="html"><![CDATA[<p><a href="http://github.com/Veraticus/Dynamoid">Dynamoid</a> is (another) gem I developed, but I think it&#8217;s a lot more exciting than <a href="http://github.com/Veraticus/rapnd">rapnd</a>! I started work on it over Christmas but didn&#8217;t really get a lot of opportunity to focus on it again until recently, when work become relatively less busy.</p>

<p>Dynamoid owes a lot to <a href="https://github.com/mongoid/mongoid">Mongoid</a> &#8211; it&#8217;s essentially trying to be for DynamoDB what Mongoid is for MongoDB. Unfortunately, it doesn&#8217;t really do a whole lot of exciting stuff yet&#8230;</p>

<p>But it will soon! The TODO list is particularly exciting:</p>

<ul>
<li>Association magic: The standard fare like belongs_to, has_many, habtm.</li>
<li>Automatic value separation and joining: Values for DynamoDB keys are limited to 64KB, but with a clever framework we can get around that constraint with multiple keys conjoined together.</li>
<li>Automatic key distribution: As per <a href="http://docs.amazonwebservices.com/amazondynamodb/latest/developerguide/BestPractices.html">Amazon&#8217;s provisioned throughput guidelines</a>, keys that are frequently accessed incur a throughput penalty due to traffic concentration. Dynamoid will distribute keys that you specify across a number of duplicated keys, and will concatenate them together when read.</li>
<li>Not-gimpy finders: Criteria like you&#8217;re used to with ActiveRecord, so that you can do User.where(:name => &#8216;Josh&#8217;) rather than User.find_by_name(&#8216;Josh&#8217;).</li>
<li>Range keys for models and indexes: To support queries like User.where(:created_at.gt => DateTime.now - 1.day)</li>
</ul>


<p>I hope to have time over the next few days and the weekend to continue improving Dynamoid. Watch this space for further updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rapnd: Redis APN Daemon]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/21/rapnd-redis-apn-daemon/"/>
    <updated>2012-02-21T13:21:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/21/rapnd-redis-apn-daemon</id>
    <content type="html"><![CDATA[<p><a href="http://github.com/Veraticus/rapnd">rapnd</a> is a gem I developed to create a persistent connection through which to pass messages to Apple&#8217;s Push Notification servers. It&#8217;s pretty neat and you should check it out.</p>

<h2>Why another push notification gem?</h2>

<p>The existing ones just didn&#8217;t do what I wanted. There were some that created persistent daemon connections&#8230; but they were only usable with one app, and we have two apps we want to send push notifications for. There were some with multiple app support, but they didn&#8217;t have daemons or they assumed the existence of ActiveRecord. And in my opinion using ActiveRecord to store notifications is pretty dumb.</p>

<h2>Whoa! ActiveRecord is just fine, bro.</h2>

<p>Yeah, I love ActiveRecord. But it&#8217;s clearly the wrong storage solution for push notifications. For every single push notification we send, we couldn&#8217;t care less about the content or whether or not it was actually delivered &#8211; so storing them in the database just built a huge table that we ended up not needing at all. Redis is the perfect solution: it can handle arbitrarily-sized lists, but doesn&#8217;t bother with any significant kind of persistence. Also, blpop made the programming a breeze.</p>

<h2>Why a daemon?</h2>

<p>Well, Apple tells you to do it. But for a more important reason, Apple claims that constantly established and dropped connections to their servers will result in IP blacklisting. I&#8217;ve never actually seen this in practice, but&#8230; well&#8230; why chance it? rapnd uses one connection per daemon and tries to keep it open as long as possible.</p>

<p>So yeah, it&#8217;s pretty cool. Go check out <a href="http://github.com/Veraticus/rapnd">the rapnd github page</a> to see the deets.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixing Redis Timeout and Unexpected Token Errors]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/21/fixing-redis-timeout-and-unexpected-token-errors/"/>
    <updated>2012-02-21T12:41:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/21/fixing-redis-timeout-and-unexpected-token-errors</id>
    <content type="html"><![CDATA[<p>Ran into some annoying problems with redis and resque recently that couldn&#8217;t be immediately solved through judicious Googling, so figured I&#8217;d make a quick post about it.</p>

<h2>Resource temporarily unavailable - Timeout reading from the socket</h2>

<p>If you installed redis-rb and hiredis by following the <a href="https://github.com/ezmobius/redis-rb">instructions at the redis-rb github page</a> then you might start running into this problem. Essentially, the version of hiredis they specify (and that you probably installed) is out of date &#8211; 0.3.1 has a known bug with socket disconnects when reading from redis. So happily, the solution to this is pretty simple: just upgrade your version of hiredis. We use 0.4.4 now.</p>

<h2>unexpected token at &#8216;OK&#8217; (Resque::Helpers::DecodeException)</h2>

<p>This one took a bit more tracking down to fix.</p>

<p>The newest versions of resque (I&#8217;m using 1.20.0) rely on versions greater than 2.4 of redis. Versions below that respond differently to certainly redis commands &#8211; for example, returning &#8220;OK.&#8221; Upgrading your redis server handily fixes this problem.</p>
]]></content>
  </entry>
  
</feed>
