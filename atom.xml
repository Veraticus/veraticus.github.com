<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Josh Symonds]]></title>
  <link href="http://Veraticus.github.com/atom.xml" rel="self"/>
  <link href="http://Veraticus.github.com/"/>
  <updated>2012-02-27T10:49:05-06:00</updated>
  <id>http://Veraticus.github.com/</id>
  <author>
    <name><![CDATA[Josh Symonds]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setting up Unicorn in a Production Environment]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/27/setting-up-unicorn-in-a-production-environment/"/>
    <updated>2012-02-27T10:20:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/27/setting-up-unicorn-in-a-production-environment</id>
    <content type="html"><![CDATA[<p>Configuring unicorn for your Rails servers is as much an art as it is a science.</p>

<p>That said, there are some things that make the configuration and setup a lot easier that I wish I had known before I had taken the unicorn plunge.</p>

<!-- more -->


<h2>worker_processes</h2>

<p>I searched high and low for a guide on how many workers each of my unicorns should employ and came up empty-handed. Unfortunately, this is highly dependent on your application. If you do complicated ImageMagick or PDF transformations on your server threads (which you shouldn&#8217;t with unicorn, but hey, who knows) then your threads will use a lot of memory, especially on those operations. For reference, our Rails app takes up about 25 megabytes of memory per worker. However, we have offloaded all of our long-running and memory-intensive tasks into Resque.</p>

<p>We use EC2&#8217;s m1.xlarge instance class and have 30 workers running per server. This number is intentionally set low; in my experience, the closer you come to maximum resource usage in an EC2 instance, the more likely it is to crash, or even worse become unresponsive.</p>

<h2>working_directory</h2>

<p>This should be fairly straightforward but has an important caveat: make sure to make this the static path of your current deploy, so the actual target of your symlink. Ours is <code>'/our/app/directory/current'</code>. Putting fanciness in here is very likely to get you shot in the foot with unicorn not reloading your app correctly, so I can&#8217;t stress enough, just make this a simple string.</p>

<h2>listen</h2>

<p>Our backlog is set to 64. If a unicorn has 64 queued connections likely it&#8217;s dead and we need failover to happen immediately; nginx takes care of that when unicorn refuses to service a request.</p>

<h2>preload_app</h2>

<p>true.</p>

<h2>Gemfile</h2>

<p>We had an issue where unicorn wouldn&#8217;t pick up our Gemfile correctly. Turns out that it doesn&#8217;t understand symlinked directories for reading gemfiles, so we had to employ this dazzling bit of code to get new gems into our bundle when the unicorns restarted:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">before_exec</span> <span class="k">do</span> <span class="o">|</span><span class="n">server</span><span class="o">|</span>
</span><span class='line'>  <span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;BUNDLE_GEMFILE&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="s1">&#39;/mnt/Hipstaweb-&lt;%= RUBBER_ENV %&gt;/current/Gemfile&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>before_fork and after_fork magic</h2>

<p>If you&#8217;re seriously considering unicorn, I&#8217;m sure you&#8217;ve seen the following gisted:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">before_fork</span> <span class="k">do</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
</span><span class='line'>  <span class="n">defined?</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="ow">and</span>
</span><span class='line'>    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">disconnect!</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">old_pid</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">server</span><span class="o">.</span><span class="n">config</span><span class="o">[</span><span class="ss">:pid</span><span class="o">]</span><span class="si">}</span><span class="s2">.oldbin&quot;</span>
</span><span class='line'>  <span class="k">if</span> <span class="no">File</span><span class="o">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">old_pid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="o">.</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">old_pid</span>
</span><span class='line'>    <span class="k">begin</span>
</span><span class='line'>      <span class="no">Process</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="s2">&quot;QUIT&quot;</span><span class="p">,</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">old_pid</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span><span class="p">)</span>
</span><span class='line'>    <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ENOENT</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ESRCH</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>ruby</p>

<p>But just to reinforce how awesome it is: this configuration is awesome. It allows your old unicorn to gracefully kill the old master while a new one seamlessly reloads. This is the key to one of unicorn&#8217;s biggest selling points &#8211; zero downtime deploys.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">after_fork</span> <span class="k">do</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
</span><span class='line'>  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">establish_connection</span>
</span><span class='line'>  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">verify_active_connections!</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you include the <code>connection.disconnect!</code> line in your before_fork, make sure you reestablish the connection in your after_fork. This prevents stale database connections and ensures each worker is always correctly connected to the database.</p>

<p>(As a postscript to this post: your unicorn servers are required to have <a href="http://en.wikipedia.org/wiki/List_of_My_Little_Pony:_Friendship_Is_Magic_characters">My Little Pony</a> character names.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Like Rubber]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/23/why-i-like-rubber/"/>
    <updated>2012-02-23T13:30:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/23/why-i-like-rubber</id>
    <content type="html"><![CDATA[<p>When I was analyzing tools to deploy applications into Amazon&#8217;s elastic cloud, I settled on <a href="https://github.com/wr0ngway/rubber">rubber</a> as our EC2 provisioner of choice.</p>

<p>rubber has a lot going for it. It provides simple, close-to-the-metal server creation and bootstrapping; it&#8217;s super easy to start a server with nothing more than:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cap rubber:create <span class="nv">ALIAS</span><span class="o">=</span>fluttershy <span class="nv">ROLES</span><span class="o">=</span>unicorn
</span></code></pre></td></tr></table></div></figure>


<p>And bootstrap it with all the software needed for that role with:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cap rubber:bootstrap <span class="nv">FILTER</span><span class="o">=</span>fluttershy
</span></code></pre></td></tr></table></div></figure>


<p>Of course, looking at command line magic doesn&#8217;t tell you anything about how hard or easy it is to initially configure, but rubber is also pretty easy to figure out and get running. When you initially rubber-ize your project, you get an entire directory in config/ called rubber that contains all the configuration files, separated by role, that you can browse to figure out exactly what rubber is doing.</p>

<p>It&#8217;s easy to extend, as well. Adding in hubot scripts to automatically start and stop our little Hipstabot was really painless and will make a good future post, I&#8217;m sure. The good part &#8211; for me at least &#8211; is how close it is to the servers and how well it ties in with Capistrano. There&#8217;s no magic going on and there&#8217;s almost nothing to learn: as long as you have an EC2 account, you can set up a server quickly and painlessly with rubber&#8230; but if you know what you&#8217;re doing, it provides an immense amount of flexibility and power to deploy whatever you want in a simple, repeatable way.</p>

<p>rubber isn&#8217;t just happiness and unicorns, though; it has some definite downsides. It seems to have a lot less mindshare than tools like Chef or Puppet, and because it&#8217;s deployed on a per-application basis, it can&#8217;t easily manage multiple applications deployed onto one machine. But despite these problems I like it a lot, and it perfectly suits our present use case.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamoid: An ORM for Amazon's DynamoDB]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/22/dynamoid-an-orm-for-amazons-dynamodb/"/>
    <updated>2012-02-22T15:00:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/22/dynamoid-an-orm-for-amazons-dynamodb</id>
    <content type="html"><![CDATA[<p><a href="http://github.com/Veraticus/Dynamoid">Dynamoid</a> is (another) gem I developed, but I think it&#8217;s a lot more exciting than <a href="http://github.com/Veraticus/rapnd">rapnd</a>! I started work on it over Christmas but didn&#8217;t really get a lot of opportunity to focus on it again until recently, when work become relatively less busy.</p>

<p>Dynamoid owes a lot to <a href="https://github.com/mongoid/mongoid">Mongoid</a> &#8211; it&#8217;s essentially trying to be for DynamoDB what Mongoid is for MongoDB. Unfortunately, it doesn&#8217;t really do a whole lot of exciting stuff yet&#8230;</p>

<p>But it will soon! The TODO list is particularly exciting:</p>

<ul>
<li>Association magic: The standard fare like belongs_to, has_many, habtm.</li>
<li>Automatic value separation and joining: Values for DynamoDB keys are limited to 64KB, but with a clever framework we can get around that constraint with multiple keys conjoined together.</li>
<li>Automatic key distribution: As per <a href="http://docs.amazonwebservices.com/amazondynamodb/latest/developerguide/BestPractices.html">Amazon&#8217;s provisioned throughput guidelines</a>, keys that are frequently accessed incur a throughput penalty due to traffic concentration. Dynamoid will distribute keys that you specify across a number of duplicated keys, and will concatenate them together when read.</li>
<li>Not-gimpy finders: Criteria like you&#8217;re used to with ActiveRecord, so that you can do User.where(:name => &#8216;Josh&#8217;) rather than User.find_by_name(&#8216;Josh&#8217;).</li>
<li>Range keys for models and indexes: To support queries like User.where(:created_at.gt => DateTime.now - 1.day)</li>
</ul>


<p>I hope to have time over the next few days and the weekend to continue improving Dynamoid. Watch this space for further updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rapnd: Redis APN Daemon]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/21/rapnd-redis-apn-daemon/"/>
    <updated>2012-02-21T13:21:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/21/rapnd-redis-apn-daemon</id>
    <content type="html"><![CDATA[<p><a href="http://github.com/Veraticus/rapnd">rapnd</a> is a gem I developed to create a persistent connection through which to pass messages to Apple&#8217;s Push Notification servers. It&#8217;s pretty neat and you should check it out.</p>

<h2>Why another push notification gem?</h2>

<p>The existing ones just didn&#8217;t do what I wanted. There were some that created persistent daemon connections&#8230; but they were only usable with one app, and we have two apps we want to send push notifications for. There were some with multiple app support, but they didn&#8217;t have daemons or they assumed the existence of ActiveRecord. And in my opinion using ActiveRecord to store notifications is pretty dumb.</p>

<h2>Whoa! ActiveRecord is just fine, bro.</h2>

<p>Yeah, I love ActiveRecord. But it&#8217;s clearly the wrong storage solution for push notifications. For every single push notification we send, we couldn&#8217;t care less about the content or whether or not it was actually delivered &#8211; so storing them in the database just built a huge table that we ended up not needing at all. Redis is the perfect solution: it can handle arbitrarily-sized lists, but doesn&#8217;t bother with any significant kind of persistence. Also, blpop made the programming a breeze.</p>

<h2>Why a daemon?</h2>

<p>Well, Apple tells you to do it. But for a more important reason, Apple claims that constantly established and dropped connections to their servers will result in IP blacklisting. I&#8217;ve never actually seen this in practice, but&#8230; well&#8230; why chance it? rapnd uses one connection per daemon and tries to keep it open as long as possible.</p>

<p>So yeah, it&#8217;s pretty cool. Go check out <a href="http://github.com/Veraticus/rapnd">the rapnd github page</a> to see the deets.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixing Redis Timeout and Unexpected Token Errors]]></title>
    <link href="http://Veraticus.github.com/blog/2012/02/21/fixing-redis-timeout-and-unexpected-token-errors/"/>
    <updated>2012-02-21T12:41:00-06:00</updated>
    <id>http://Veraticus.github.com/blog/2012/02/21/fixing-redis-timeout-and-unexpected-token-errors</id>
    <content type="html"><![CDATA[<p>Ran into some annoying problems with redis and resque recently that couldn&#8217;t be immediately solved through judicious Googling, so figured I&#8217;d make a quick post about it.</p>

<h2>Resource temporarily unavailable - Timeout reading from the socket</h2>

<p>If you installed redis-rb and hiredis by following the <a href="https://github.com/ezmobius/redis-rb">instructions at the redis-rb github page</a> then you might start running into this problem. Essentially, the version of hiredis they specify (and that you probably installed) is out of date &#8211; 0.3.1 has a known bug with socket disconnects when reading from redis. So happily, the solution to this is pretty simple: just upgrade your version of hiredis. We use 0.4.4 now.</p>

<h2>unexpected token at &#8216;OK&#8217; (Resque::Helpers::DecodeException)</h2>

<p>This one took a bit more tracking down to fix.</p>

<p>The newest versions of resque (I&#8217;m using 1.20.0) rely on versions greater than 2.4 of redis. Versions below that respond differently to certainly redis commands &#8211; for example, returning &#8220;OK.&#8221; Upgrading your redis server handily fixes this problem.</p>
]]></content>
  </entry>
  
</feed>
